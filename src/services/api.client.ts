//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IApiClient {
    billingConfirm(storeId: string | null, transactionId: string | null): Promise<void>;
    billingPaymentmethods(storeId: string | null): Promise<BillingPaymentMethodViewModel[]>;
    billingHistory(storeId: string | null, request: BaseSearchRequest): Promise<PaginatedResultOfInvoiceViewModel>;
    billingGet(storeId: string | null): Promise<InvoiceViewModel[]>;
    billingPayment(storeId: string | null): Promise<void>;
    billingPaymentmethodPut(storeId: string | null, clientSecret: string): Promise<AddPaymentMethodResponse>;
    billingPaymentmethodDelete(storeId: string | null, paymentMethodId: string | null): Promise<void>;
    billingFeatures(storeId: string | null): Promise<StorePlatformFeatureViewModel[]>;
    billingPaymentmethodDefault(storeId: string | null, paymentMethodId: string): Promise<void>;
    billingFeatureToggle(storeId: string | null, isAnnualRenewal: boolean, feature: PlatformFeatureTypeEnum): Promise<void>;
    billingDelete(storeId: string | null, invoiceId: string | null): Promise<void>;
    billingManual(storeId: string | null, invoice: InvoiceViewModel): Promise<void>;
    billingPaymentManual(storeId: string | null, invoiceId: string): Promise<void>;
    bookingGet(restaurantId: string | null, dateFrom: Date | null, dateTo: Date | null): Promise<BookingViewModel[]>;
    bookingPut(restaurantId: string | null, booking: BookingViewModel): Promise<void>;
    bookingStatus(restaurantId: string | null, bookingId: string | null, status: BookingStatusEnum): Promise<void>;
    bookingNotify(restaurantId: string | null, bookingId: string | null, notificationMediumTypeId: NotificationMediumTypeEnum): Promise<void>;
    campaignPost(restaurantId: string | null, campaign: CampaignViewModel): Promise<void>;
    campaignGet(restaurantId: string | null, campaignId: string | null): Promise<void>;
    campaignVoucherPost(restaurantId: string | null, voucher: VoucherViewModel, campaignId: string): Promise<void>;
    campaignVoucherGet(restaurantId: string | null, voucherId: string | null, campaignId: string, voucher: string): Promise<void>;
    customerGet(restaurantId: string | null, customerId: string | null): Promise<CustomerViewModel>;
    customerDelete(restaurantId: string | null, customerId: string | null): Promise<void>;
    customerPut(restaurantId: string | null, customer: CustomerViewModel): Promise<string>;
    customerSearch(restaurantId: string | null, request: CustomerSearchRequest): Promise<PaginatedResultOfCustomerViewModel>;
    customerAutocomplete(restaurantId: string | null, query: string | null): Promise<SelectOptionViewModel[]>;
    dashboard(restaurantId: string | null): Promise<ChartViewModel[]>;
    deviceGet(restaurantId: string | null, machineId: string | null): Promise<DeviceViewModel>;
    devices(restaurantId: string | null, loadAll: boolean): Promise<DeviceViewModel[]>;
    devicePut(restaurantId: string | null, request: DeviceViewModel): Promise<string>;
    deviceDelete(restaurantId: string | null, deviceId: string | null): Promise<void>;
    devicePost(restaurantId: string | null, deviceId: string | null, device: DeviceViewModel): Promise<void>;
    deviceBind(restaurantId: string | null, deviceId: string | null, deviceMachineId: string | null): Promise<string>;
    devicePrinterPost(restaurantId: string | null, deviceId: string | null, printer: PrinterViewModel): Promise<void>;
    devicePrinterDelete(restaurantId: string | null, deviceId: string | null, printerId: string | null): Promise<void>;
    devicePrinterTest(restaurantId: string | null, deviceId: string | null, printerId: string | null): Promise<string>;
    deviceOpenCashbox(restaurantId: string | null, deviceId: string | null, printerId?: string | null | undefined): Promise<string>;
    deviceSettings(restaurantId: string | null, deviceId: string | null, deviceSettings: DeviceSettingsViewModel): Promise<void>;
    documentUpload(restaurantId: string | null, document: RestaurantDocumentViewModel): Promise<void>;
    documentSearch(restaurantId: string | null, searchRequest: DocumentSearchRequest): Promise<PaginatedResultOfRestaurantDocumentViewModel>;
    documentDownload(restaurantId: string | null, documentId: string | null): Promise<FileResponse>;
    documentInvoice(restaurantId: string | null, invoice: InvoiceViewModel): Promise<FileResponse>;
    globalTimezones(): Promise<{ [key: string]: string; }>;
    globalLanguages(): Promise<Language[]>;
    globalAgreementsGet(): Promise<LegalAgreementViewModel[]>;
    globalAgreementsPost(legalAgreement: LegalAgreementViewModel): Promise<void>;
    globalAgreement(agreementId: string | null): Promise<LegalAgreementViewModel>;
    globalTransactionsStatus(transactionId: string | null, transactionStatus: TransactionStatusEnum): Promise<void>;
    globalInvoices(date: Date): Promise<void>;
    globalActivityLog(request: ActivityLogSearchRequest): Promise<PaginatedResultOfActivityLogViewModel>;
    globalRoles(): Promise<RoleViewModel[]>;
    globalRolePost(role: RoleViewModel): Promise<void>;
    globalRoleDelete(roleId: string | null): Promise<void>;
    globalCache(cacheKey: string | null): Promise<void>;
    globalStoresAutocomplete(query: string | null): Promise<SelectOptionViewModel[]>;
    globalSessions(dateFrom: Date, dateTo: Date): Promise<{ [key: string]: number; }>;
    globalFeaturesGet(): Promise<PlatformFeatureViewModel[]>;
    globalFeaturesPost(features: PlatformFeatureViewModel[]): Promise<void>;
    inventoryProducts(restaurantId: string | null): Promise<InventoryProductListItemViewModel[]>;
    inventoryProductDelete(restaurantId: string | null, productId: string | null): Promise<void>;
    inventoryProductGet(restaurantId: string | null, productId: string | null): Promise<InventoryProductViewModel>;
    inventoryProductHistory(restaurantId: string | null, productId: string | null, request: BaseSearchRequest): Promise<PaginatedResultOfInventoryProductStockRecordViewModel>;
    inventoryProductPut(restaurantId: string | null, product: InventoryProductViewModel): Promise<void>;
    inventoryCategory(restaurantId: string | null, category: InventoryProductCategoryViewModel): Promise<void>;
    inventoryCategoriesDelete(restaurantId: string | null, categoryId: string | null): Promise<void>;
    inventorySearch(restaurantId: string | null, request: InventoryProductSearchRequest): Promise<PaginatedResultOfInventoryProductViewModel>;
    inventoryCategoriesGet(restaurantId: string | null): Promise<InventoryProductCategoryViewModel[]>;
    inventoryStock(restaurantId: string | null, request: InventoryProductStockRecordViewModel): Promise<void>;
    inventoryAutocomplete(restaurantId: string | null, query: string | null): Promise<InventoryProductSelectOptionViewModel[]>;
    menuPut(restaurantId: string | null, menu: MenuViewModel): Promise<MenuViewModel>;
    menuMappings(restaurantId: string | null, loadHidden?: boolean | undefined): Promise<MenuViewModel>;
    menuGet(restaurantId: string | null, menuId: string | null): Promise<MenuViewModel>;
    menuDelete(restaurantId: string | null, menuId: string | null): Promise<void>;
    menuAll(restaurantId: string | null, pageIdx: number | null, pageSize: number | null): Promise<PaginatedResultOfMenuListItemViewModel>;
    menuItemVisibility(restaurantId: string | null, menuItemId: string | null, isVisible: boolean): Promise<void>;
    menuCategoryVisibility(restaurantId: string | null, categoryItemId: string | null, isVisible: boolean): Promise<void>;
    orderDeliveryStatus(storeId: string | null, orderId: string | null, orderStatus: OrderStatusEnum): Promise<void>;
    orderPrint(storeId: string | null, orderId: string | null, printerId: string | null, categoriesId: string[]): Promise<string>;
    orderStatus(storeId: string | null, orderId: string | null, request: UpdateOrderStatusRequest): Promise<void>;
    orderHistory(storeId: string | null, searchRequest: OrderSearchRequest): Promise<PaginatedResultOfOrderListItemViewModel>;
    orderDetail(storeId: string | null, orderId: string | null): Promise<OrderViewModel>;
    order(storeId: string | null, order: OrderViewModel): Promise<CreateOrderResponse>;
    orderRefund(storeId: string | null, orderId: string | null, request: RefundRequest): Promise<OrderViewModel>;
    orderCheckTransactions(storeId: string | null, orderId: string | null): Promise<void>;
    ordersAccountModifier(restaurantId: string | null, ordersAccountId: string | null, request: UpdatePriceModifierRequest): Promise<void>;
    ordersAccountRefund(restaurantId: string | null, ordersAccountId: string | null, request: RefundRequest): Promise<OrdersAccountViewModel>;
    ordersAccountSettle(restaurantId: string | null, ordersAccountId: string | null, request: CreateManualTransactionRequest): Promise<ManualTransactionResponse>;
    ordersAccountCheckTransactions(restaurantId: string | null, ordersAccountId: string | null): Promise<void>;
    ordersAccountReject(restaurantId: string | null, ordersAccountId: string | null, rejectedSessionId: string): Promise<void>;
    ordersAccountAccept(restaurantId: string | null, ordersAccountId: string | null, acceptedSessionId: string): Promise<void>;
    ordersAccountSessions(restaurantId: string | null, ordersAccountId: string | null): Promise<OrdersAccountSessionViewModel[]>;
    ordersAccountTransactions(restaurantId: string | null, ordersAccountId: string | null): Promise<OrdersAccountTransactionViewModel[]>;
    ordersAccountCheck(restaurantId: string | null, ordersAccountId: string | null): Promise<void>;
    ordersAccountDetail(restaurantId: string | null, ordersAccountId: string | null): Promise<OrdersAccountViewModel>;
    ordersAccountTable(restaurantId: string | null, ordersAccountId: string | null, tableId: string): Promise<void>;
    ordersAccountPrint(restaurantId: string | null, ordersAccountId: string | null, printerId: string | null, categoriesId: string[]): Promise<string>;
    receiptPrint(restaurantId: string | null, receiptId: string | null, deviceId: string | null): Promise<string>;
    receipt(restaurantId: string | null, receiptId: string | null): Promise<ReceiptViewModel>;
    receiptCustomer(restaurantId: string | null, receiptId: string | null, customerId: string): Promise<ReceiptViewModel>;
    receiptRefund(restaurantId: string | null, receiptId: string | null, amountToRefund: number): Promise<ReceiptViewModel>;
    receiptPaymentprovider(restaurantId: string | null, receiptId: string | null, paymentProviderType: PaymentProviderEnum): Promise<ReceiptViewModel>;
    receipts(restaurantId: string | null, request: ReceiptSearchRequest): Promise<PaginatedResultOfReceiptViewModel>;
    report(storeId: string | null, dateFrom: Date, dateTo: Date): Promise<EndOfPeriodReportViewModel>;
    reportPrintItems(storeId: string | null, dateFrom: Date, dateTo: Date, deviceId: string | null): Promise<string>;
    reportPrintSummary(storeId: string | null, dateFrom: Date, dateTo: Date, deviceId: string | null): Promise<string>;
    restaurantFull(storeId: string | null): Promise<StoreFullViewModel>;
    restaurantGet(storeId: string | null): Promise<StoreViewModel>;
    restaurantTableautojoin(storeId: string | null, allowAutoJoin: boolean): Promise<void>;
    restaurantOrderstatus(storeId: string | null, orderTypeId: OrderTypeEnum, isOpen: boolean): Promise<void>;
    restaurantPut(store: StoreFullViewModel): Promise<StoreFullViewModel>;
    restaurantStatus(storeId: string | null, isActive: boolean): Promise<void>;
    restaurantAll(request: RestaurantSearchRequest): Promise<PaginatedResultOfStoreViewModel>;
    restaurantTablegroupsGet(storeId: string | null): Promise<TableGroupViewModel[]>;
    restaurantTablegroupsPost(storeId: string | null, tableGroups: TableGroupViewModel[]): Promise<void>;
    restaurantTablegroupsDelete(storeId: string | null, tableGroupId: string | null): Promise<void>;
    restaurantTablesStatus(storeId: string | null, tableId: string | null, isActive: boolean): Promise<void>;
    restaurantTablesPrint(storeId: string | null, tableId: string | null, printerId: string | null): Promise<string>;
    restaurantTablesDownload(storeId: string | null, tableGroupId: string | null, options: DownloadTablesFileOptions): Promise<FileResponse>;
    restaurantMenu(storeId: string | null, menuId: string | null): Promise<void>;
    restaurantNotificationsPost(storeId: string | null, request: BaseSearchRequest): Promise<PaginatedResultOfNotificationViewModel>;
    restaurantNotificationsPatch(storeId: string | null, notificationId: string | null): Promise<void>;
    restaurantPrinters(storeId: string | null, deviceId?: string | null | undefined): Promise<PrinterViewModel[]>;
    restaurantTransactions(storeId: string | null, request: TransactionSearchRequest): Promise<PaginatedResultOfTransactionViewModel>;
    restaurantReceipts(storeId: string | null, request: ReceiptSearchRequest): Promise<PaginatedResultOfReceiptViewModel>;
    restaurantPaymententityCreate(storeId: string | null, paymentProvider: PaymentProviderEnum): Promise<void>;
    restaurantPaymentInstruments(storeId: string | null, paymentProvider: PaymentProviderEnum): Promise<void>;
    instrumentsCreate(storeId: string | null, bankInstrumentModel: BankInstrumentModel, paymentProvider: PaymentProviderEnum): Promise<BankInstrumentResponseModel>;
    instrumentsGet(instrumentId: string | null, paymentProvider: PaymentProviderEnum): Promise<BankInstrumentResponseModel>;
    restaurantsupplierPost(restaurantId: string | null, supplier: SupplierViewModel): Promise<void>;
    restaurantsupplierProduct(restaurantId: string | null, product: SupplierProductViewModel, supplierId: string): Promise<void>;
    restaurantsupplierSearch(restaurantId: string | null, request: SupplierSearchRequest): Promise<PaginatedResultOfSupplierViewModel>;
    restaurantsupplierDelete(restaurantId: string | null, supplierId: string | null): Promise<void>;
    restaurantsupplierAutocomplete(restaurantId: string | null, query: string | null): Promise<SelectOptionViewModel[]>;
    cashtakingOpen(storeId: string | null, initialAmount: number): Promise<void>;
    cashtakingClose(storeId: string | null, cashTaking: CashTakingViewModel): Promise<void>;
    cashtakingPrint(storeId: string | null, cashTakingId: string | null, deviceId: string | null): Promise<string>;
    cashtakingsGet(storeId: string | null): Promise<CashTakingViewModel>;
    cashtakingsPost(storeId: string | null, request: CashTakingSearchRequest): Promise<PaginatedResultOfCashTakingViewModel>;
    internaltransactions(storeId: string | null, request: RestaurantTransactionSearchRequest): Promise<PaginatedResultOfRestaurantTransactionViewModel>;
    internaltransaction(storeId: string | null, transaction: RestaurantTransactionViewModel): Promise<void>;
    userDeviceLogin(request: LoginRequest): Promise<DeviceLoginResponse>;
    userLogin(request: LoginRequest): Promise<PlatformUserViewModel>;
    userAuthenticatorLogin(request: LoginAuthenticatorRequest): Promise<PlatformUserViewModel>;
    userAuthenticatorGet(): Promise<ValueTupleOfStringAndString>;
    userAuthenticatorPost(code: string): Promise<void>;
    userSettings(request: ChangeSettingsRequest): Promise<void>;
    userPin(request: ChangePinRequest): Promise<string>;
    userPassword(request: ChangePasswordRequest): Promise<void>;
    userGet(): Promise<PlatformUserViewModel>;
    userPost(user: PlatformUserViewModel): Promise<PlatformUserViewModel>;
    userAutocomplete(query: string | null): Promise<SelectOptionViewModel[]>;
    userAll(request: PlatformUserSearchRequest): Promise<PaginatedResultOfPlatformUserViewModel>;
    userStatus(userId: string | null, isActive: boolean): Promise<void>;
    userDelete(userId: string | null): Promise<void>;
    userRestaurantRoles(restaurantId: string | null): Promise<RoleViewModel[]>;
    voucherDelete(restaurantId: string | null, voucherId: string | null): Promise<void>;
    voucherPost(restaurantId: string | null, voucher: VoucherViewModel): Promise<void>;
    voucherSearch(restaurantId: string | null, request: VoucherSearchRequest): Promise<PaginatedResultOfVoucherViewModel>;
}

export class ApiClient implements IApiClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    billingConfirm(storeId: string | null, transactionId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/billing/confirm/{transactionId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingConfirm(_response);
        });
    }

    protected processBillingConfirm(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    billingPaymentmethods(storeId: string | null , cancelToken?: CancelToken | undefined): Promise<BillingPaymentMethodViewModel[]> {
        let url_ = this.baseUrl + "/{storeId}/billing/paymentmethods";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingPaymentmethods(_response);
        });
    }

    protected processBillingPaymentmethods(response: AxiosResponse): Promise<BillingPaymentMethodViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BillingPaymentMethodViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BillingPaymentMethodViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingPaymentMethodViewModel[]>(null as any);
    }

    billingHistory(storeId: string | null, request: BaseSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfInvoiceViewModel> {
        let url_ = this.baseUrl + "/{storeId}/billing/history";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingHistory(_response);
        });
    }

    protected processBillingHistory(response: AxiosResponse): Promise<PaginatedResultOfInvoiceViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfInvoiceViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfInvoiceViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfInvoiceViewModel>(null as any);
    }

    billingGet(storeId: string | null , cancelToken?: CancelToken | undefined): Promise<InvoiceViewModel[]> {
        let url_ = this.baseUrl + "/{storeId}/billing";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingGet(_response);
        });
    }

    protected processBillingGet(response: AxiosResponse): Promise<InvoiceViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<InvoiceViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InvoiceViewModel[]>(null as any);
    }

    billingPayment(storeId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/billing/payment";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingPayment(_response);
        });
    }

    protected processBillingPayment(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    billingPaymentmethodPut(storeId: string | null, clientSecret: string , cancelToken?: CancelToken | undefined): Promise<AddPaymentMethodResponse> {
        let url_ = this.baseUrl + "/{storeId}/billing/paymentmethod";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(clientSecret);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingPaymentmethodPut(_response);
        });
    }

    protected processBillingPaymentmethodPut(response: AxiosResponse): Promise<AddPaymentMethodResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AddPaymentMethodResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<AddPaymentMethodResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddPaymentMethodResponse>(null as any);
    }

    billingPaymentmethodDelete(storeId: string | null, paymentMethodId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/billing/paymentmethod/{paymentMethodId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (paymentMethodId === undefined || paymentMethodId === null)
            throw new Error("The parameter 'paymentMethodId' must be defined.");
        url_ = url_.replace("{paymentMethodId}", encodeURIComponent("" + paymentMethodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingPaymentmethodDelete(_response);
        });
    }

    protected processBillingPaymentmethodDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    billingFeatures(storeId: string | null , cancelToken?: CancelToken | undefined): Promise<StorePlatformFeatureViewModel[]> {
        let url_ = this.baseUrl + "/{storeId}/billing/features";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingFeatures(_response);
        });
    }

    protected processBillingFeatures(response: AxiosResponse): Promise<StorePlatformFeatureViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StorePlatformFeatureViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<StorePlatformFeatureViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StorePlatformFeatureViewModel[]>(null as any);
    }

    billingPaymentmethodDefault(storeId: string | null, paymentMethodId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/billing/paymentmethod/default";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentMethodId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingPaymentmethodDefault(_response);
        });
    }

    protected processBillingPaymentmethodDefault(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    billingFeatureToggle(storeId: string | null, isAnnualRenewal: boolean, feature: PlatformFeatureTypeEnum , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/billing/feature/toggle?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (isAnnualRenewal === undefined || isAnnualRenewal === null)
            throw new Error("The parameter 'isAnnualRenewal' must be defined and cannot be null.");
        else
            url_ += "isAnnualRenewal=" + encodeURIComponent("" + isAnnualRenewal) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(feature);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingFeatureToggle(_response);
        });
    }

    protected processBillingFeatureToggle(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    billingDelete(storeId: string | null, invoiceId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/billing/{invoiceId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingDelete(_response);
        });
    }

    protected processBillingDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    billingManual(storeId: string | null, invoice: InvoiceViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/billing/manual";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invoice);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingManual(_response);
        });
    }

    protected processBillingManual(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    billingPaymentManual(storeId: string | null, invoiceId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/billing/payment/manual";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invoiceId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBillingPaymentManual(_response);
        });
    }

    protected processBillingPaymentManual(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    bookingGet(restaurantId: string | null, dateFrom: Date | null, dateTo: Date | null , cancelToken?: CancelToken | undefined): Promise<BookingViewModel[]> {
        let url_ = this.baseUrl + "/{restaurantId}/booking?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (dateFrom === undefined)
            throw new Error("The parameter 'dateFrom' must be defined.");
        else if(dateFrom !== null)
            url_ += "DateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined)
            throw new Error("The parameter 'dateTo' must be defined.");
        else if(dateTo !== null)
            url_ += "DateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBookingGet(_response);
        });
    }

    protected processBookingGet(response: AxiosResponse): Promise<BookingViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BookingViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BookingViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookingViewModel[]>(null as any);
    }

    bookingPut(restaurantId: string | null, booking: BookingViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/booking";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(booking);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBookingPut(_response);
        });
    }

    protected processBookingPut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    bookingStatus(restaurantId: string | null, bookingId: string | null, status: BookingStatusEnum , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/booking/{bookingId}/status";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (bookingId === undefined || bookingId === null)
            throw new Error("The parameter 'bookingId' must be defined.");
        url_ = url_.replace("{bookingId}", encodeURIComponent("" + bookingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(status);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBookingStatus(_response);
        });
    }

    protected processBookingStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    bookingNotify(restaurantId: string | null, bookingId: string | null, notificationMediumTypeId: NotificationMediumTypeEnum , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/booking/{bookingId}/notify/{notificationMediumTypeId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (bookingId === undefined || bookingId === null)
            throw new Error("The parameter 'bookingId' must be defined.");
        url_ = url_.replace("{bookingId}", encodeURIComponent("" + bookingId));
        if (notificationMediumTypeId === undefined || notificationMediumTypeId === null)
            throw new Error("The parameter 'notificationMediumTypeId' must be defined.");
        url_ = url_.replace("{notificationMediumTypeId}", encodeURIComponent("" + notificationMediumTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBookingNotify(_response);
        });
    }

    protected processBookingNotify(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    campaignPost(restaurantId: string | null, campaign: CampaignViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/campaign";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(campaign);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCampaignPost(_response);
        });
    }

    protected processCampaignPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    campaignGet(restaurantId: string | null, campaignId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/campaign/{campaignId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined.");
        url_ = url_.replace("{campaignId}", encodeURIComponent("" + campaignId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCampaignGet(_response);
        });
    }

    protected processCampaignGet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    campaignVoucherPost(restaurantId: string | null, voucher: VoucherViewModel, campaignId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/campaign/{campaignId}/voucher";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined.");
        url_ = url_.replace("{campaignId}", encodeURIComponent("" + campaignId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(voucher);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCampaignVoucherPost(_response);
        });
    }

    protected processCampaignVoucherPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    campaignVoucherGet(restaurantId: string | null, voucherId: string | null, campaignId: string, voucher: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/campaign/{campaignId}/voucher/{voucher}?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (campaignId === undefined || campaignId === null)
            throw new Error("The parameter 'campaignId' must be defined.");
        url_ = url_.replace("{campaignId}", encodeURIComponent("" + campaignId));
        if (voucher === undefined || voucher === null)
            throw new Error("The parameter 'voucher' must be defined.");
        url_ = url_.replace("{voucher}", encodeURIComponent("" + voucher));
        if (voucherId === undefined)
            throw new Error("The parameter 'voucherId' must be defined.");
        else if(voucherId !== null)
            url_ += "voucherId=" + encodeURIComponent("" + voucherId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCampaignVoucherGet(_response);
        });
    }

    protected processCampaignVoucherGet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    customerGet(restaurantId: string | null, customerId: string | null , cancelToken?: CancelToken | undefined): Promise<CustomerViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/customer/{customerId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerGet(_response);
        });
    }

    protected processCustomerGet(response: AxiosResponse): Promise<CustomerViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<CustomerViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerViewModel>(null as any);
    }

    customerDelete(restaurantId: string | null, customerId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/customer/{customerId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerDelete(_response);
        });
    }

    protected processCustomerDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    customerPut(restaurantId: string | null, customer: CustomerViewModel , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{restaurantId}/customer";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(customer);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerPut(_response);
        });
    }

    protected processCustomerPut(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    customerSearch(restaurantId: string | null, request: CustomerSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfCustomerViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/customer/search";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerSearch(_response);
        });
    }

    protected processCustomerSearch(response: AxiosResponse): Promise<PaginatedResultOfCustomerViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfCustomerViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfCustomerViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfCustomerViewModel>(null as any);
    }

    customerAutocomplete(restaurantId: string | null, query: string | null , cancelToken?: CancelToken | undefined): Promise<SelectOptionViewModel[]> {
        let url_ = this.baseUrl + "/{restaurantId}/customer/autocomplete?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (query === undefined)
            throw new Error("The parameter 'query' must be defined.");
        else if(query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerAutocomplete(_response);
        });
    }

    protected processCustomerAutocomplete(response: AxiosResponse): Promise<SelectOptionViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectOptionViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SelectOptionViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SelectOptionViewModel[]>(null as any);
    }

    dashboard(restaurantId: string | null , cancelToken?: CancelToken | undefined): Promise<ChartViewModel[]> {
        let url_ = this.baseUrl + "/dashboard/{restaurantId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDashboard(_response);
        });
    }

    protected processDashboard(response: AxiosResponse): Promise<ChartViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ChartViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChartViewModel[]>(null as any);
    }

    deviceGet(restaurantId: string | null, machineId: string | null , cancelToken?: CancelToken | undefined): Promise<DeviceViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/device/{machineId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (machineId === undefined || machineId === null)
            throw new Error("The parameter 'machineId' must be defined.");
        url_ = url_.replace("{machineId}", encodeURIComponent("" + machineId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeviceGet(_response);
        });
    }

    protected processDeviceGet(response: AxiosResponse): Promise<DeviceViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<DeviceViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceViewModel>(null as any);
    }

    devices(restaurantId: string | null, loadAll: boolean , cancelToken?: CancelToken | undefined): Promise<DeviceViewModel[]> {
        let url_ = this.baseUrl + "/{restaurantId}/devices?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (loadAll === undefined || loadAll === null)
            throw new Error("The parameter 'loadAll' must be defined and cannot be null.");
        else
            url_ += "loadAll=" + encodeURIComponent("" + loadAll) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDevices(_response);
        });
    }

    protected processDevices(response: AxiosResponse): Promise<DeviceViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceViewModel[]>(null as any);
    }

    devicePut(restaurantId: string | null, request: DeviceViewModel , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{restaurantId}/device";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDevicePut(_response);
        });
    }

    protected processDevicePut(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    deviceDelete(restaurantId: string | null, deviceId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/device/{deviceId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeviceDelete(_response);
        });
    }

    protected processDeviceDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    devicePost(restaurantId: string | null, deviceId: string | null, device: DeviceViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/device/{deviceId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(device);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDevicePost(_response);
        });
    }

    protected processDevicePost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deviceBind(restaurantId: string | null, deviceId: string | null, deviceMachineId: string | null , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{restaurantId}/device/{deviceId}/bind?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (deviceMachineId === undefined)
            throw new Error("The parameter 'deviceMachineId' must be defined.");
        else if(deviceMachineId !== null)
            url_ += "deviceMachineId=" + encodeURIComponent("" + deviceMachineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeviceBind(_response);
        });
    }

    protected processDeviceBind(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    devicePrinterPost(restaurantId: string | null, deviceId: string | null, printer: PrinterViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/device/{deviceId}/printer";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(printer);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDevicePrinterPost(_response);
        });
    }

    protected processDevicePrinterPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    devicePrinterDelete(restaurantId: string | null, deviceId: string | null, printerId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/device/{deviceId}/printer/{printerId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (printerId === undefined || printerId === null)
            throw new Error("The parameter 'printerId' must be defined.");
        url_ = url_.replace("{printerId}", encodeURIComponent("" + printerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDevicePrinterDelete(_response);
        });
    }

    protected processDevicePrinterDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    devicePrinterTest(restaurantId: string | null, deviceId: string | null, printerId: string | null , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{restaurantId}/device/{deviceId}/printer/{printerId}/test";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (printerId === undefined || printerId === null)
            throw new Error("The parameter 'printerId' must be defined.");
        url_ = url_.replace("{printerId}", encodeURIComponent("" + printerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDevicePrinterTest(_response);
        });
    }

    protected processDevicePrinterTest(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    deviceOpenCashbox(restaurantId: string | null, deviceId: string | null, printerId?: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{restaurantId}/device/{deviceId}/open-cashbox?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (printerId !== undefined && printerId !== null)
            url_ += "printerId=" + encodeURIComponent("" + printerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeviceOpenCashbox(_response);
        });
    }

    protected processDeviceOpenCashbox(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    deviceSettings(restaurantId: string | null, deviceId: string | null, deviceSettings: DeviceSettingsViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/device/{deviceId}/settings";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceSettings);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeviceSettings(_response);
        });
    }

    protected processDeviceSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    documentUpload(restaurantId: string | null, document: RestaurantDocumentViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/document/upload";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(document);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDocumentUpload(_response);
        });
    }

    protected processDocumentUpload(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    documentSearch(restaurantId: string | null, searchRequest: DocumentSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfRestaurantDocumentViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/document/search";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDocumentSearch(_response);
        });
    }

    protected processDocumentSearch(response: AxiosResponse): Promise<PaginatedResultOfRestaurantDocumentViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfRestaurantDocumentViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfRestaurantDocumentViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfRestaurantDocumentViewModel>(null as any);
    }

    documentDownload(restaurantId: string | null, documentId: string | null , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/{restaurantId}/document/{documentId}/download";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDocumentDownload(_response);
        });
    }

    protected processDocumentDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    documentInvoice(restaurantId: string | null, invoice: InvoiceViewModel , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/{restaurantId}/document/invoice";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invoice);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDocumentInvoice(_response);
        });
    }

    protected processDocumentInvoice(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    globalTimezones(  cancelToken?: CancelToken | undefined): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/global/timezones";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalTimezones(_response);
        });
    }

    protected processGlobalTimezones(response: AxiosResponse): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<{ [key: string]: string; }>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: string; }>(null as any);
    }

    globalLanguages(  cancelToken?: CancelToken | undefined): Promise<Language[]> {
        let url_ = this.baseUrl + "/global/languages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalLanguages(_response);
        });
    }

    protected processGlobalLanguages(response: AxiosResponse): Promise<Language[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Language.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Language[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Language[]>(null as any);
    }

    globalAgreementsGet(  cancelToken?: CancelToken | undefined): Promise<LegalAgreementViewModel[]> {
        let url_ = this.baseUrl + "/global/agreements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalAgreementsGet(_response);
        });
    }

    protected processGlobalAgreementsGet(response: AxiosResponse): Promise<LegalAgreementViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LegalAgreementViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LegalAgreementViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LegalAgreementViewModel[]>(null as any);
    }

    globalAgreementsPost(legalAgreement: LegalAgreementViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/global/agreements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(legalAgreement);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalAgreementsPost(_response);
        });
    }

    protected processGlobalAgreementsPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    globalAgreement(agreementId: string | null , cancelToken?: CancelToken | undefined): Promise<LegalAgreementViewModel> {
        let url_ = this.baseUrl + "/global/agreement/{agreementId}";
        if (agreementId === undefined || agreementId === null)
            throw new Error("The parameter 'agreementId' must be defined.");
        url_ = url_.replace("{agreementId}", encodeURIComponent("" + agreementId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalAgreement(_response);
        });
    }

    protected processGlobalAgreement(response: AxiosResponse): Promise<LegalAgreementViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LegalAgreementViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<LegalAgreementViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LegalAgreementViewModel>(null as any);
    }

    globalTransactionsStatus(transactionId: string | null, transactionStatus: TransactionStatusEnum , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/global/transactions/{transactionId}/status?";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        if (transactionStatus === undefined || transactionStatus === null)
            throw new Error("The parameter 'transactionStatus' must be defined and cannot be null.");
        else
            url_ += "transactionStatus=" + encodeURIComponent("" + transactionStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalTransactionsStatus(_response);
        });
    }

    protected processGlobalTransactionsStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    globalInvoices(date: Date , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/global/invoices?";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalInvoices(_response);
        });
    }

    protected processGlobalInvoices(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    globalActivityLog(request: ActivityLogSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfActivityLogViewModel> {
        let url_ = this.baseUrl + "/global/activity-log";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalActivityLog(_response);
        });
    }

    protected processGlobalActivityLog(response: AxiosResponse): Promise<PaginatedResultOfActivityLogViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfActivityLogViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfActivityLogViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfActivityLogViewModel>(null as any);
    }

    globalRoles(  cancelToken?: CancelToken | undefined): Promise<RoleViewModel[]> {
        let url_ = this.baseUrl + "/global/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalRoles(_response);
        });
    }

    protected processGlobalRoles(response: AxiosResponse): Promise<RoleViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RoleViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleViewModel[]>(null as any);
    }

    globalRolePost(role: RoleViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/global/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalRolePost(_response);
        });
    }

    protected processGlobalRolePost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    globalRoleDelete(roleId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/global/role/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalRoleDelete(_response);
        });
    }

    protected processGlobalRoleDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    globalCache(cacheKey: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/global/cache/{cacheKey}";
        if (cacheKey === undefined || cacheKey === null)
            throw new Error("The parameter 'cacheKey' must be defined.");
        url_ = url_.replace("{cacheKey}", encodeURIComponent("" + cacheKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalCache(_response);
        });
    }

    protected processGlobalCache(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    globalStoresAutocomplete(query: string | null , cancelToken?: CancelToken | undefined): Promise<SelectOptionViewModel[]> {
        let url_ = this.baseUrl + "/global/stores/autocomplete?";
        if (query === undefined)
            throw new Error("The parameter 'query' must be defined.");
        else if(query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalStoresAutocomplete(_response);
        });
    }

    protected processGlobalStoresAutocomplete(response: AxiosResponse): Promise<SelectOptionViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectOptionViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SelectOptionViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SelectOptionViewModel[]>(null as any);
    }

    globalSessions(dateFrom: Date, dateTo: Date , cancelToken?: CancelToken | undefined): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/global/sessions?";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalSessions(_response);
        });
    }

    protected processGlobalSessions(response: AxiosResponse): Promise<{ [key: string]: number; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<{ [key: string]: number; }>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    globalFeaturesGet(  cancelToken?: CancelToken | undefined): Promise<PlatformFeatureViewModel[]> {
        let url_ = this.baseUrl + "/global/features";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalFeaturesGet(_response);
        });
    }

    protected processGlobalFeaturesGet(response: AxiosResponse): Promise<PlatformFeatureViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlatformFeatureViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PlatformFeatureViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlatformFeatureViewModel[]>(null as any);
    }

    globalFeaturesPost(features: PlatformFeatureViewModel[] , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/global/features";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(features);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalFeaturesPost(_response);
        });
    }

    protected processGlobalFeaturesPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    inventoryProducts(restaurantId: string | null , cancelToken?: CancelToken | undefined): Promise<InventoryProductListItemViewModel[]> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/products";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryProducts(_response);
        });
    }

    protected processInventoryProducts(response: AxiosResponse): Promise<InventoryProductListItemViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryProductListItemViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<InventoryProductListItemViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InventoryProductListItemViewModel[]>(null as any);
    }

    inventoryProductDelete(restaurantId: string | null, productId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/product/{productId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryProductDelete(_response);
        });
    }

    protected processInventoryProductDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    inventoryProductGet(restaurantId: string | null, productId: string | null , cancelToken?: CancelToken | undefined): Promise<InventoryProductViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/product/{productId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryProductGet(_response);
        });
    }

    protected processInventoryProductGet(response: AxiosResponse): Promise<InventoryProductViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InventoryProductViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<InventoryProductViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InventoryProductViewModel>(null as any);
    }

    inventoryProductHistory(restaurantId: string | null, productId: string | null, request: BaseSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfInventoryProductStockRecordViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/product/{productId}/history";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryProductHistory(_response);
        });
    }

    protected processInventoryProductHistory(response: AxiosResponse): Promise<PaginatedResultOfInventoryProductStockRecordViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfInventoryProductStockRecordViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfInventoryProductStockRecordViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfInventoryProductStockRecordViewModel>(null as any);
    }

    inventoryProductPut(restaurantId: string | null, product: InventoryProductViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/product";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(product);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryProductPut(_response);
        });
    }

    protected processInventoryProductPut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    inventoryCategory(restaurantId: string | null, category: InventoryProductCategoryViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/category";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(category);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryCategory(_response);
        });
    }

    protected processInventoryCategory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    inventoryCategoriesDelete(restaurantId: string | null, categoryId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/categories/{categoryId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryCategoriesDelete(_response);
        });
    }

    protected processInventoryCategoriesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    inventorySearch(restaurantId: string | null, request: InventoryProductSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfInventoryProductViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/search";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventorySearch(_response);
        });
    }

    protected processInventorySearch(response: AxiosResponse): Promise<PaginatedResultOfInventoryProductViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfInventoryProductViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfInventoryProductViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfInventoryProductViewModel>(null as any);
    }

    inventoryCategoriesGet(restaurantId: string | null , cancelToken?: CancelToken | undefined): Promise<InventoryProductCategoryViewModel[]> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/categories";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryCategoriesGet(_response);
        });
    }

    protected processInventoryCategoriesGet(response: AxiosResponse): Promise<InventoryProductCategoryViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryProductCategoryViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<InventoryProductCategoryViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InventoryProductCategoryViewModel[]>(null as any);
    }

    inventoryStock(restaurantId: string | null, request: InventoryProductStockRecordViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/stock";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryStock(_response);
        });
    }

    protected processInventoryStock(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    inventoryAutocomplete(restaurantId: string | null, query: string | null , cancelToken?: CancelToken | undefined): Promise<InventoryProductSelectOptionViewModel[]> {
        let url_ = this.baseUrl + "/{restaurantId}/inventory/autocomplete?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (query === undefined)
            throw new Error("The parameter 'query' must be defined.");
        else if(query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInventoryAutocomplete(_response);
        });
    }

    protected processInventoryAutocomplete(response: AxiosResponse): Promise<InventoryProductSelectOptionViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryProductSelectOptionViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<InventoryProductSelectOptionViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InventoryProductSelectOptionViewModel[]>(null as any);
    }

    menuPut(restaurantId: string | null, menu: MenuViewModel , cancelToken?: CancelToken | undefined): Promise<MenuViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/menu";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(menu);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuPut(_response);
        });
    }

    protected processMenuPut(response: AxiosResponse): Promise<MenuViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<MenuViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuViewModel>(null as any);
    }

    menuMappings(restaurantId: string | null, loadHidden?: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<MenuViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/menu/mappings?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (loadHidden === null)
            throw new Error("The parameter 'loadHidden' cannot be null.");
        else if (loadHidden !== undefined)
            url_ += "loadHidden=" + encodeURIComponent("" + loadHidden) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuMappings(_response);
        });
    }

    protected processMenuMappings(response: AxiosResponse): Promise<MenuViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<MenuViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuViewModel>(null as any);
    }

    menuGet(restaurantId: string | null, menuId: string | null , cancelToken?: CancelToken | undefined): Promise<MenuViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/menu/{menuId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (menuId === undefined || menuId === null)
            throw new Error("The parameter 'menuId' must be defined.");
        url_ = url_.replace("{menuId}", encodeURIComponent("" + menuId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuGet(_response);
        });
    }

    protected processMenuGet(response: AxiosResponse): Promise<MenuViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<MenuViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuViewModel>(null as any);
    }

    menuDelete(restaurantId: string | null, menuId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/menu/{menuId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (menuId === undefined || menuId === null)
            throw new Error("The parameter 'menuId' must be defined.");
        url_ = url_.replace("{menuId}", encodeURIComponent("" + menuId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuDelete(_response);
        });
    }

    protected processMenuDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    menuAll(restaurantId: string | null, pageIdx: number | null, pageSize: number | null , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfMenuListItemViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/menu/all?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (pageIdx === undefined)
            throw new Error("The parameter 'pageIdx' must be defined.");
        else if(pageIdx !== null)
            url_ += "pageIdx=" + encodeURIComponent("" + pageIdx) + "&";
        if (pageSize === undefined)
            throw new Error("The parameter 'pageSize' must be defined.");
        else if(pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuAll(_response);
        });
    }

    protected processMenuAll(response: AxiosResponse): Promise<PaginatedResultOfMenuListItemViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfMenuListItemViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfMenuListItemViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfMenuListItemViewModel>(null as any);
    }

    menuItemVisibility(restaurantId: string | null, menuItemId: string | null, isVisible: boolean , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/menu/item/{menuItemId}/visibility";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (menuItemId === undefined || menuItemId === null)
            throw new Error("The parameter 'menuItemId' must be defined.");
        url_ = url_.replace("{menuItemId}", encodeURIComponent("" + menuItemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(isVisible);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemVisibility(_response);
        });
    }

    protected processMenuItemVisibility(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    menuCategoryVisibility(restaurantId: string | null, categoryItemId: string | null, isVisible: boolean , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/menu/category/{categoryItemId}/visibility";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (categoryItemId === undefined || categoryItemId === null)
            throw new Error("The parameter 'categoryItemId' must be defined.");
        url_ = url_.replace("{categoryItemId}", encodeURIComponent("" + categoryItemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(isVisible);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuCategoryVisibility(_response);
        });
    }

    protected processMenuCategoryVisibility(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    orderDeliveryStatus(storeId: string | null, orderId: string | null, orderStatus: OrderStatusEnum , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/order/{orderId}/delivery/status";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(orderStatus);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderDeliveryStatus(_response);
        });
    }

    protected processOrderDeliveryStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    orderPrint(storeId: string | null, orderId: string | null, printerId: string | null, categoriesId: string[] , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{storeId}/order/{orderId}/print/{printerId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        if (printerId === undefined || printerId === null)
            throw new Error("The parameter 'printerId' must be defined.");
        url_ = url_.replace("{printerId}", encodeURIComponent("" + printerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(categoriesId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderPrint(_response);
        });
    }

    protected processOrderPrint(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    orderStatus(storeId: string | null, orderId: string | null, request: UpdateOrderStatusRequest , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/order/{orderId}/status";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderStatus(_response);
        });
    }

    protected processOrderStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    orderHistory(storeId: string | null, searchRequest: OrderSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfOrderListItemViewModel> {
        let url_ = this.baseUrl + "/{storeId}/order/history";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderHistory(_response);
        });
    }

    protected processOrderHistory(response: AxiosResponse): Promise<PaginatedResultOfOrderListItemViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfOrderListItemViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfOrderListItemViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfOrderListItemViewModel>(null as any);
    }

    orderDetail(storeId: string | null, orderId: string | null , cancelToken?: CancelToken | undefined): Promise<OrderViewModel> {
        let url_ = this.baseUrl + "/{storeId}/order/{orderId}/detail";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderDetail(_response);
        });
    }

    protected processOrderDetail(response: AxiosResponse): Promise<OrderViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrderViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<OrderViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderViewModel>(null as any);
    }

    order(storeId: string | null, order: OrderViewModel , cancelToken?: CancelToken | undefined): Promise<CreateOrderResponse> {
        let url_ = this.baseUrl + "/{storeId}/order";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(order);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrder(_response);
        });
    }

    protected processOrder(response: AxiosResponse): Promise<CreateOrderResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateOrderResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<CreateOrderResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateOrderResponse>(null as any);
    }

    orderRefund(storeId: string | null, orderId: string | null, request: RefundRequest , cancelToken?: CancelToken | undefined): Promise<OrderViewModel> {
        let url_ = this.baseUrl + "/{storeId}/order/{orderId}/refund";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderRefund(_response);
        });
    }

    protected processOrderRefund(response: AxiosResponse): Promise<OrderViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrderViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<OrderViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrderViewModel>(null as any);
    }

    orderCheckTransactions(storeId: string | null, orderId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/order/{orderId}/check-transactions";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrderCheckTransactions(_response);
        });
    }

    protected processOrderCheckTransactions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    ordersAccountModifier(restaurantId: string | null, ordersAccountId: string | null, request: UpdatePriceModifierRequest , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/modifier";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountModifier(_response);
        });
    }

    protected processOrdersAccountModifier(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    ordersAccountRefund(restaurantId: string | null, ordersAccountId: string | null, request: RefundRequest , cancelToken?: CancelToken | undefined): Promise<OrdersAccountViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/refund";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountRefund(_response);
        });
    }

    protected processOrdersAccountRefund(response: AxiosResponse): Promise<OrdersAccountViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrdersAccountViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<OrdersAccountViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrdersAccountViewModel>(null as any);
    }

    ordersAccountSettle(restaurantId: string | null, ordersAccountId: string | null, request: CreateManualTransactionRequest , cancelToken?: CancelToken | undefined): Promise<ManualTransactionResponse> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/settle";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountSettle(_response);
        });
    }

    protected processOrdersAccountSettle(response: AxiosResponse): Promise<ManualTransactionResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ManualTransactionResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<ManualTransactionResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ManualTransactionResponse>(null as any);
    }

    ordersAccountCheckTransactions(restaurantId: string | null, ordersAccountId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/check-transactions";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountCheckTransactions(_response);
        });
    }

    protected processOrdersAccountCheckTransactions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    ordersAccountReject(restaurantId: string | null, ordersAccountId: string | null, rejectedSessionId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/reject";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rejectedSessionId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountReject(_response);
        });
    }

    protected processOrdersAccountReject(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    ordersAccountAccept(restaurantId: string | null, ordersAccountId: string | null, acceptedSessionId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/accept";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(acceptedSessionId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountAccept(_response);
        });
    }

    protected processOrdersAccountAccept(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    ordersAccountSessions(restaurantId: string | null, ordersAccountId: string | null , cancelToken?: CancelToken | undefined): Promise<OrdersAccountSessionViewModel[]> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/sessions";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountSessions(_response);
        });
    }

    protected processOrdersAccountSessions(response: AxiosResponse): Promise<OrdersAccountSessionViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrdersAccountSessionViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrdersAccountSessionViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrdersAccountSessionViewModel[]>(null as any);
    }

    ordersAccountTransactions(restaurantId: string | null, ordersAccountId: string | null , cancelToken?: CancelToken | undefined): Promise<OrdersAccountTransactionViewModel[]> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/transactions";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountTransactions(_response);
        });
    }

    protected processOrdersAccountTransactions(response: AxiosResponse): Promise<OrdersAccountTransactionViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrdersAccountTransactionViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrdersAccountTransactionViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrdersAccountTransactionViewModel[]>(null as any);
    }

    ordersAccountCheck(restaurantId: string | null, ordersAccountId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/check";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountCheck(_response);
        });
    }

    protected processOrdersAccountCheck(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    ordersAccountDetail(restaurantId: string | null, ordersAccountId: string | null , cancelToken?: CancelToken | undefined): Promise<OrdersAccountViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/detail";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountDetail(_response);
        });
    }

    protected processOrdersAccountDetail(response: AxiosResponse): Promise<OrdersAccountViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrdersAccountViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<OrdersAccountViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrdersAccountViewModel>(null as any);
    }

    ordersAccountTable(restaurantId: string | null, ordersAccountId: string | null, tableId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/table";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountTable(_response);
        });
    }

    protected processOrdersAccountTable(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    ordersAccountPrint(restaurantId: string | null, ordersAccountId: string | null, printerId: string | null, categoriesId: string[] , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{restaurantId}/orders-account/{ordersAccountId}/print/{printerId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (ordersAccountId === undefined || ordersAccountId === null)
            throw new Error("The parameter 'ordersAccountId' must be defined.");
        url_ = url_.replace("{ordersAccountId}", encodeURIComponent("" + ordersAccountId));
        if (printerId === undefined || printerId === null)
            throw new Error("The parameter 'printerId' must be defined.");
        url_ = url_.replace("{printerId}", encodeURIComponent("" + printerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(categoriesId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrdersAccountPrint(_response);
        });
    }

    protected processOrdersAccountPrint(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    receiptPrint(restaurantId: string | null, receiptId: string | null, deviceId: string | null , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{restaurantId}/receipt/{receiptId}/print?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (receiptId === undefined || receiptId === null)
            throw new Error("The parameter 'receiptId' must be defined.");
        url_ = url_.replace("{receiptId}", encodeURIComponent("" + receiptId));
        if (deviceId === undefined)
            throw new Error("The parameter 'deviceId' must be defined.");
        else if(deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceiptPrint(_response);
        });
    }

    protected processReceiptPrint(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    receipt(restaurantId: string | null, receiptId: string | null , cancelToken?: CancelToken | undefined): Promise<ReceiptViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/receipt/{receiptId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (receiptId === undefined || receiptId === null)
            throw new Error("The parameter 'receiptId' must be defined.");
        url_ = url_.replace("{receiptId}", encodeURIComponent("" + receiptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceipt(_response);
        });
    }

    protected processReceipt(response: AxiosResponse): Promise<ReceiptViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReceiptViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<ReceiptViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiptViewModel>(null as any);
    }

    receiptCustomer(restaurantId: string | null, receiptId: string | null, customerId: string , cancelToken?: CancelToken | undefined): Promise<ReceiptViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/receipt/{receiptId}/customer";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (receiptId === undefined || receiptId === null)
            throw new Error("The parameter 'receiptId' must be defined.");
        url_ = url_.replace("{receiptId}", encodeURIComponent("" + receiptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(customerId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceiptCustomer(_response);
        });
    }

    protected processReceiptCustomer(response: AxiosResponse): Promise<ReceiptViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReceiptViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<ReceiptViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiptViewModel>(null as any);
    }

    receiptRefund(restaurantId: string | null, receiptId: string | null, amountToRefund: number , cancelToken?: CancelToken | undefined): Promise<ReceiptViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/receipt/{receiptId}/refund";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (receiptId === undefined || receiptId === null)
            throw new Error("The parameter 'receiptId' must be defined.");
        url_ = url_.replace("{receiptId}", encodeURIComponent("" + receiptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(amountToRefund);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceiptRefund(_response);
        });
    }

    protected processReceiptRefund(response: AxiosResponse): Promise<ReceiptViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReceiptViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<ReceiptViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiptViewModel>(null as any);
    }

    receiptPaymentprovider(restaurantId: string | null, receiptId: string | null, paymentProviderType: PaymentProviderEnum , cancelToken?: CancelToken | undefined): Promise<ReceiptViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/receipt/{receiptId}/paymentprovider";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (receiptId === undefined || receiptId === null)
            throw new Error("The parameter 'receiptId' must be defined.");
        url_ = url_.replace("{receiptId}", encodeURIComponent("" + receiptId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentProviderType);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceiptPaymentprovider(_response);
        });
    }

    protected processReceiptPaymentprovider(response: AxiosResponse): Promise<ReceiptViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReceiptViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<ReceiptViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiptViewModel>(null as any);
    }

    receipts(restaurantId: string | null, request: ReceiptSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfReceiptViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/receipts";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReceipts(_response);
        });
    }

    protected processReceipts(response: AxiosResponse): Promise<PaginatedResultOfReceiptViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfReceiptViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfReceiptViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfReceiptViewModel>(null as any);
    }

    report(storeId: string | null, dateFrom: Date, dateTo: Date , cancelToken?: CancelToken | undefined): Promise<EndOfPeriodReportViewModel> {
        let url_ = this.baseUrl + "/{storeId}/report?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReport(_response);
        });
    }

    protected processReport(response: AxiosResponse): Promise<EndOfPeriodReportViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EndOfPeriodReportViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<EndOfPeriodReportViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EndOfPeriodReportViewModel>(null as any);
    }

    reportPrintItems(storeId: string | null, dateFrom: Date, dateTo: Date, deviceId: string | null , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{storeId}/report/print/items?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (deviceId === undefined)
            throw new Error("The parameter 'deviceId' must be defined.");
        else if(deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportPrintItems(_response);
        });
    }

    protected processReportPrintItems(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    reportPrintSummary(storeId: string | null, dateFrom: Date, dateTo: Date, deviceId: string | null , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{storeId}/report/print/summary?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (deviceId === undefined)
            throw new Error("The parameter 'deviceId' must be defined.");
        else if(deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReportPrintSummary(_response);
        });
    }

    protected processReportPrintSummary(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    restaurantFull(storeId: string | null , cancelToken?: CancelToken | undefined): Promise<StoreFullViewModel> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/full";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantFull(_response);
        });
    }

    protected processRestaurantFull(response: AxiosResponse): Promise<StoreFullViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StoreFullViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<StoreFullViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StoreFullViewModel>(null as any);
    }

    restaurantGet(storeId: string | null , cancelToken?: CancelToken | undefined): Promise<StoreViewModel> {
        let url_ = this.baseUrl + "/restaurant/{storeId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantGet(_response);
        });
    }

    protected processRestaurantGet(response: AxiosResponse): Promise<StoreViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StoreViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<StoreViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StoreViewModel>(null as any);
    }

    restaurantTableautojoin(storeId: string | null, allowAutoJoin: boolean , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/tableautojoin?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (allowAutoJoin === undefined || allowAutoJoin === null)
            throw new Error("The parameter 'allowAutoJoin' must be defined and cannot be null.");
        else
            url_ += "allowAutoJoin=" + encodeURIComponent("" + allowAutoJoin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantTableautojoin(_response);
        });
    }

    protected processRestaurantTableautojoin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantOrderstatus(storeId: string | null, orderTypeId: OrderTypeEnum, isOpen: boolean , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/orderstatus/{orderTypeId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (orderTypeId === undefined || orderTypeId === null)
            throw new Error("The parameter 'orderTypeId' must be defined.");
        url_ = url_.replace("{orderTypeId}", encodeURIComponent("" + orderTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(isOpen);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantOrderstatus(_response);
        });
    }

    protected processRestaurantOrderstatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantPut(store: StoreFullViewModel , cancelToken?: CancelToken | undefined): Promise<StoreFullViewModel> {
        let url_ = this.baseUrl + "/restaurant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(store);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantPut(_response);
        });
    }

    protected processRestaurantPut(response: AxiosResponse): Promise<StoreFullViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StoreFullViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<StoreFullViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StoreFullViewModel>(null as any);
    }

    restaurantStatus(storeId: string | null, isActive: boolean , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/status";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(isActive);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantStatus(_response);
        });
    }

    protected processRestaurantStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantAll(request: RestaurantSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfStoreViewModel> {
        let url_ = this.baseUrl + "/restaurant/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantAll(_response);
        });
    }

    protected processRestaurantAll(response: AxiosResponse): Promise<PaginatedResultOfStoreViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfStoreViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfStoreViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfStoreViewModel>(null as any);
    }

    restaurantTablegroupsGet(storeId: string | null , cancelToken?: CancelToken | undefined): Promise<TableGroupViewModel[]> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/tablegroups";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantTablegroupsGet(_response);
        });
    }

    protected processRestaurantTablegroupsGet(response: AxiosResponse): Promise<TableGroupViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TableGroupViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TableGroupViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TableGroupViewModel[]>(null as any);
    }

    restaurantTablegroupsPost(storeId: string | null, tableGroups: TableGroupViewModel[] , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/tablegroups";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableGroups);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantTablegroupsPost(_response);
        });
    }

    protected processRestaurantTablegroupsPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantTablegroupsDelete(storeId: string | null, tableGroupId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/tablegroups/{tableGroupId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (tableGroupId === undefined || tableGroupId === null)
            throw new Error("The parameter 'tableGroupId' must be defined.");
        url_ = url_.replace("{tableGroupId}", encodeURIComponent("" + tableGroupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantTablegroupsDelete(_response);
        });
    }

    protected processRestaurantTablegroupsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantTablesStatus(storeId: string | null, tableId: string | null, isActive: boolean , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/tables/{tableId}/status";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (tableId === undefined || tableId === null)
            throw new Error("The parameter 'tableId' must be defined.");
        url_ = url_.replace("{tableId}", encodeURIComponent("" + tableId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(isActive);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantTablesStatus(_response);
        });
    }

    protected processRestaurantTablesStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantTablesPrint(storeId: string | null, tableId: string | null, printerId: string | null , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/tables/{tableId}/print/{printerId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (tableId === undefined || tableId === null)
            throw new Error("The parameter 'tableId' must be defined.");
        url_ = url_.replace("{tableId}", encodeURIComponent("" + tableId));
        if (printerId === undefined || printerId === null)
            throw new Error("The parameter 'printerId' must be defined.");
        url_ = url_.replace("{printerId}", encodeURIComponent("" + printerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantTablesPrint(_response);
        });
    }

    protected processRestaurantTablesPrint(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    restaurantTablesDownload(storeId: string | null, tableGroupId: string | null, options: DownloadTablesFileOptions , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/tables/{tableGroupId}/download";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (tableGroupId === undefined || tableGroupId === null)
            throw new Error("The parameter 'tableGroupId' must be defined.");
        url_ = url_.replace("{tableGroupId}", encodeURIComponent("" + tableGroupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantTablesDownload(_response);
        });
    }

    protected processRestaurantTablesDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    restaurantMenu(storeId: string | null, menuId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/menu/{menuId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (menuId === undefined || menuId === null)
            throw new Error("The parameter 'menuId' must be defined.");
        url_ = url_.replace("{menuId}", encodeURIComponent("" + menuId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantMenu(_response);
        });
    }

    protected processRestaurantMenu(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantNotificationsPost(storeId: string | null, request: BaseSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfNotificationViewModel> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/notifications";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantNotificationsPost(_response);
        });
    }

    protected processRestaurantNotificationsPost(response: AxiosResponse): Promise<PaginatedResultOfNotificationViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfNotificationViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfNotificationViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfNotificationViewModel>(null as any);
    }

    restaurantNotificationsPatch(storeId: string | null, notificationId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/notifications/{notificationId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (notificationId === undefined || notificationId === null)
            throw new Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantNotificationsPatch(_response);
        });
    }

    protected processRestaurantNotificationsPatch(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantPrinters(storeId: string | null, deviceId?: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<PrinterViewModel[]> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/printers?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (deviceId !== undefined && deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantPrinters(_response);
        });
    }

    protected processRestaurantPrinters(response: AxiosResponse): Promise<PrinterViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PrinterViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PrinterViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PrinterViewModel[]>(null as any);
    }

    restaurantTransactions(storeId: string | null, request: TransactionSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfTransactionViewModel> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/transactions";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantTransactions(_response);
        });
    }

    protected processRestaurantTransactions(response: AxiosResponse): Promise<PaginatedResultOfTransactionViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfTransactionViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfTransactionViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfTransactionViewModel>(null as any);
    }

    restaurantReceipts(storeId: string | null, request: ReceiptSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfReceiptViewModel> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/receipts";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantReceipts(_response);
        });
    }

    protected processRestaurantReceipts(response: AxiosResponse): Promise<PaginatedResultOfReceiptViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfReceiptViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfReceiptViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfReceiptViewModel>(null as any);
    }

    restaurantPaymententityCreate(storeId: string | null, paymentProvider: PaymentProviderEnum , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/paymententity/create?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (paymentProvider === undefined || paymentProvider === null)
            throw new Error("The parameter 'paymentProvider' must be defined and cannot be null.");
        else
            url_ += "paymentProvider=" + encodeURIComponent("" + paymentProvider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantPaymententityCreate(_response);
        });
    }

    protected processRestaurantPaymententityCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantPaymentInstruments(storeId: string | null, paymentProvider: PaymentProviderEnum , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/restaurant/{storeId}/payment/instruments?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (paymentProvider === undefined || paymentProvider === null)
            throw new Error("The parameter 'paymentProvider' must be defined and cannot be null.");
        else
            url_ += "paymentProvider=" + encodeURIComponent("" + paymentProvider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantPaymentInstruments(_response);
        });
    }

    protected processRestaurantPaymentInstruments(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    instrumentsCreate(storeId: string | null, bankInstrumentModel: BankInstrumentModel, paymentProvider: PaymentProviderEnum , cancelToken?: CancelToken | undefined): Promise<BankInstrumentResponseModel> {
        let url_ = this.baseUrl + "/instruments/create?";
        if (storeId === undefined)
            throw new Error("The parameter 'storeId' must be defined.");
        else if(storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (paymentProvider === undefined || paymentProvider === null)
            throw new Error("The parameter 'paymentProvider' must be defined and cannot be null.");
        else
            url_ += "paymentProvider=" + encodeURIComponent("" + paymentProvider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bankInstrumentModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInstrumentsCreate(_response);
        });
    }

    protected processInstrumentsCreate(response: AxiosResponse): Promise<BankInstrumentResponseModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankInstrumentResponseModel.fromJS(resultData200, _mappings);
            return Promise.resolve<BankInstrumentResponseModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankInstrumentResponseModel>(null as any);
    }

    instrumentsGet(instrumentId: string | null, paymentProvider: PaymentProviderEnum , cancelToken?: CancelToken | undefined): Promise<BankInstrumentResponseModel> {
        let url_ = this.baseUrl + "/instruments/get?";
        if (instrumentId === undefined)
            throw new Error("The parameter 'instrumentId' must be defined.");
        else if(instrumentId !== null)
            url_ += "instrumentId=" + encodeURIComponent("" + instrumentId) + "&";
        if (paymentProvider === undefined || paymentProvider === null)
            throw new Error("The parameter 'paymentProvider' must be defined and cannot be null.");
        else
            url_ += "paymentProvider=" + encodeURIComponent("" + paymentProvider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInstrumentsGet(_response);
        });
    }

    protected processInstrumentsGet(response: AxiosResponse): Promise<BankInstrumentResponseModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankInstrumentResponseModel.fromJS(resultData200, _mappings);
            return Promise.resolve<BankInstrumentResponseModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankInstrumentResponseModel>(null as any);
    }

    restaurantsupplierPost(restaurantId: string | null, supplier: SupplierViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/restaurantsupplier";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(supplier);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantsupplierPost(_response);
        });
    }

    protected processRestaurantsupplierPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantsupplierProduct(restaurantId: string | null, product: SupplierProductViewModel, supplierId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/restaurantsupplier/{supplierId}/product";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (supplierId === undefined || supplierId === null)
            throw new Error("The parameter 'supplierId' must be defined.");
        url_ = url_.replace("{supplierId}", encodeURIComponent("" + supplierId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(product);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantsupplierProduct(_response);
        });
    }

    protected processRestaurantsupplierProduct(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantsupplierSearch(restaurantId: string | null, request: SupplierSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfSupplierViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/restaurantsupplier/search";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantsupplierSearch(_response);
        });
    }

    protected processRestaurantsupplierSearch(response: AxiosResponse): Promise<PaginatedResultOfSupplierViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfSupplierViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfSupplierViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfSupplierViewModel>(null as any);
    }

    restaurantsupplierDelete(restaurantId: string | null, supplierId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/restaurantsupplier/{supplierId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (supplierId === undefined || supplierId === null)
            throw new Error("The parameter 'supplierId' must be defined.");
        url_ = url_.replace("{supplierId}", encodeURIComponent("" + supplierId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantsupplierDelete(_response);
        });
    }

    protected processRestaurantsupplierDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    restaurantsupplierAutocomplete(restaurantId: string | null, query: string | null , cancelToken?: CancelToken | undefined): Promise<SelectOptionViewModel[]> {
        let url_ = this.baseUrl + "/{restaurantId}/restaurantsupplier/autocomplete?";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (query === undefined)
            throw new Error("The parameter 'query' must be defined.");
        else if(query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestaurantsupplierAutocomplete(_response);
        });
    }

    protected processRestaurantsupplierAutocomplete(response: AxiosResponse): Promise<SelectOptionViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectOptionViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SelectOptionViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SelectOptionViewModel[]>(null as any);
    }

    cashtakingOpen(storeId: string | null, initialAmount: number , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/cashtaking/open";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(initialAmount);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCashtakingOpen(_response);
        });
    }

    protected processCashtakingOpen(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    cashtakingClose(storeId: string | null, cashTaking: CashTakingViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/cashtaking/close";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cashTaking);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCashtakingClose(_response);
        });
    }

    protected processCashtakingClose(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    cashtakingPrint(storeId: string | null, cashTakingId: string | null, deviceId: string | null , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/{storeId}/cashtaking/{cashTakingId}/print?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (cashTakingId === undefined || cashTakingId === null)
            throw new Error("The parameter 'cashTakingId' must be defined.");
        url_ = url_.replace("{cashTakingId}", encodeURIComponent("" + cashTakingId));
        if (deviceId === undefined)
            throw new Error("The parameter 'deviceId' must be defined.");
        else if(deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCashtakingPrint(_response);
        });
    }

    protected processCashtakingPrint(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    cashtakingsGet(storeId: string | null , cancelToken?: CancelToken | undefined): Promise<CashTakingViewModel> {
        let url_ = this.baseUrl + "/{storeId}/cashtakings";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCashtakingsGet(_response);
        });
    }

    protected processCashtakingsGet(response: AxiosResponse): Promise<CashTakingViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CashTakingViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<CashTakingViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CashTakingViewModel>(null as any);
    }

    cashtakingsPost(storeId: string | null, request: CashTakingSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfCashTakingViewModel> {
        let url_ = this.baseUrl + "/{storeId}/cashtakings";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCashtakingsPost(_response);
        });
    }

    protected processCashtakingsPost(response: AxiosResponse): Promise<PaginatedResultOfCashTakingViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfCashTakingViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfCashTakingViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfCashTakingViewModel>(null as any);
    }

    internaltransactions(storeId: string | null, request: RestaurantTransactionSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfRestaurantTransactionViewModel> {
        let url_ = this.baseUrl + "/{storeId}/internaltransactions";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInternaltransactions(_response);
        });
    }

    protected processInternaltransactions(response: AxiosResponse): Promise<PaginatedResultOfRestaurantTransactionViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfRestaurantTransactionViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfRestaurantTransactionViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfRestaurantTransactionViewModel>(null as any);
    }

    internaltransaction(storeId: string | null, transaction: RestaurantTransactionViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{storeId}/internaltransaction";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(transaction);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInternaltransaction(_response);
        });
    }

    protected processInternaltransaction(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    userDeviceLogin(request: LoginRequest , cancelToken?: CancelToken | undefined): Promise<DeviceLoginResponse> {
        let url_ = this.baseUrl + "/user/device-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserDeviceLogin(_response);
        });
    }

    protected processUserDeviceLogin(response: AxiosResponse): Promise<DeviceLoginResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceLoginResponse.fromJS(resultData200, _mappings);
            return Promise.resolve<DeviceLoginResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceLoginResponse>(null as any);
    }

    userLogin(request: LoginRequest , cancelToken?: CancelToken | undefined): Promise<PlatformUserViewModel> {
        let url_ = this.baseUrl + "/user/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserLogin(_response);
        });
    }

    protected processUserLogin(response: AxiosResponse): Promise<PlatformUserViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlatformUserViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PlatformUserViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlatformUserViewModel>(null as any);
    }

    userAuthenticatorLogin(request: LoginAuthenticatorRequest , cancelToken?: CancelToken | undefined): Promise<PlatformUserViewModel> {
        let url_ = this.baseUrl + "/user/authenticator/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserAuthenticatorLogin(_response);
        });
    }

    protected processUserAuthenticatorLogin(response: AxiosResponse): Promise<PlatformUserViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlatformUserViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PlatformUserViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlatformUserViewModel>(null as any);
    }

    userAuthenticatorGet(  cancelToken?: CancelToken | undefined): Promise<ValueTupleOfStringAndString> {
        let url_ = this.baseUrl + "/user/authenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserAuthenticatorGet(_response);
        });
    }

    protected processUserAuthenticatorGet(response: AxiosResponse): Promise<ValueTupleOfStringAndString> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ValueTupleOfStringAndString.fromJS(resultData200, _mappings);
            return Promise.resolve<ValueTupleOfStringAndString>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ValueTupleOfStringAndString>(null as any);
    }

    userAuthenticatorPost(code: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/user/authenticator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(code);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserAuthenticatorPost(_response);
        });
    }

    protected processUserAuthenticatorPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    userSettings(request: ChangeSettingsRequest , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/user/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserSettings(_response);
        });
    }

    protected processUserSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    userPin(request: ChangePinRequest , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/user/pin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserPin(_response);
        });
    }

    protected processUserPin(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    userPassword(request: ChangePasswordRequest , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/user/password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserPassword(_response);
        });
    }

    protected processUserPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    userGet(  cancelToken?: CancelToken | undefined): Promise<PlatformUserViewModel> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserGet(_response);
        });
    }

    protected processUserGet(response: AxiosResponse): Promise<PlatformUserViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlatformUserViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PlatformUserViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlatformUserViewModel>(null as any);
    }

    userPost(user: PlatformUserViewModel , cancelToken?: CancelToken | undefined): Promise<PlatformUserViewModel> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserPost(_response);
        });
    }

    protected processUserPost(response: AxiosResponse): Promise<PlatformUserViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlatformUserViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PlatformUserViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlatformUserViewModel>(null as any);
    }

    userAutocomplete(query: string | null , cancelToken?: CancelToken | undefined): Promise<SelectOptionViewModel[]> {
        let url_ = this.baseUrl + "/user/autocomplete?";
        if (query === undefined)
            throw new Error("The parameter 'query' must be defined.");
        else if(query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserAutocomplete(_response);
        });
    }

    protected processUserAutocomplete(response: AxiosResponse): Promise<SelectOptionViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectOptionViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SelectOptionViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SelectOptionViewModel[]>(null as any);
    }

    userAll(request: PlatformUserSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfPlatformUserViewModel> {
        let url_ = this.baseUrl + "/user/all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserAll(_response);
        });
    }

    protected processUserAll(response: AxiosResponse): Promise<PaginatedResultOfPlatformUserViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfPlatformUserViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfPlatformUserViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfPlatformUserViewModel>(null as any);
    }

    userStatus(userId: string | null, isActive: boolean , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/user/{userId}/status";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(isActive);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserStatus(_response);
        });
    }

    protected processUserStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    userDelete(userId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserDelete(_response);
        });
    }

    protected processUserDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    userRestaurantRoles(restaurantId: string | null , cancelToken?: CancelToken | undefined): Promise<RoleViewModel[]> {
        let url_ = this.baseUrl + "/user/restaurant/{restaurantId}/roles";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserRestaurantRoles(_response);
        });
    }

    protected processUserRestaurantRoles(response: AxiosResponse): Promise<RoleViewModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleViewModel.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RoleViewModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleViewModel[]>(null as any);
    }

    voucherDelete(restaurantId: string | null, voucherId: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/voucher/{voucherId}";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        if (voucherId === undefined || voucherId === null)
            throw new Error("The parameter 'voucherId' must be defined.");
        url_ = url_.replace("{voucherId}", encodeURIComponent("" + voucherId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVoucherDelete(_response);
        });
    }

    protected processVoucherDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    voucherPost(restaurantId: string | null, voucher: VoucherViewModel , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/{restaurantId}/voucher";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(voucher);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVoucherPost(_response);
        });
    }

    protected processVoucherPost(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    voucherSearch(restaurantId: string | null, request: VoucherSearchRequest , cancelToken?: CancelToken | undefined): Promise<PaginatedResultOfVoucherViewModel> {
        let url_ = this.baseUrl + "/{restaurantId}/voucher/search";
        if (restaurantId === undefined || restaurantId === null)
            throw new Error("The parameter 'restaurantId' must be defined.");
        url_ = url_.replace("{restaurantId}", encodeURIComponent("" + restaurantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVoucherSearch(_response);
        });
    }

    protected processVoucherSearch(response: AxiosResponse): Promise<PaginatedResultOfVoucherViewModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedResultOfVoucherViewModel.fromJS(resultData200, _mappings);
            return Promise.resolve<PaginatedResultOfVoucherViewModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedResultOfVoucherViewModel>(null as any);
    }
}

export class BillingPaymentMethodViewModel implements IBillingPaymentMethodViewModel {
    id!: string | undefined;
    last4!: string | undefined;
    bin!: string | undefined;
    scheme!: string | undefined;
    expiryMonth!: number | undefined;
    expiryYear!: number | undefined;
    createdAt!: Date;

    constructor(data?: IBillingPaymentMethodViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.last4 = _data["last4"];
            this.bin = _data["bin"];
            this.scheme = _data["scheme"];
            this.expiryMonth = _data["expiryMonth"];
            this.expiryYear = _data["expiryYear"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): BillingPaymentMethodViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BillingPaymentMethodViewModel>(data, _mappings, BillingPaymentMethodViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["last4"] = this.last4;
        data["bin"] = this.bin;
        data["scheme"] = this.scheme;
        data["expiryMonth"] = this.expiryMonth;
        data["expiryYear"] = this.expiryYear;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBillingPaymentMethodViewModel {
    id: string | undefined;
    last4: string | undefined;
    bin: string | undefined;
    scheme: string | undefined;
    expiryMonth: number | undefined;
    expiryYear: number | undefined;
    createdAt: Date;
}

export class PaginatedResultOfInvoiceViewModel implements IPaginatedResultOfInvoiceViewModel {
    items!: InvoiceViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfInvoiceViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InvoiceViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfInvoiceViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfInvoiceViewModel>(data, _mappings, PaginatedResultOfInvoiceViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfInvoiceViewModel {
    items: InvoiceViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class InvoiceViewModel implements IInvoiceViewModel {
    id!: string | undefined;
    amount!: number;
    vatAmount!: number;
    number!: number;
    currencySymbol!: string | undefined;
    documentId!: string | undefined;
    items!: KeyValuePairOfStringAndDouble[] | undefined;
    notes!: string | undefined;
    date!: Date;
    emittingCompany!: CompanyViewModel | undefined;
    receivingCompany!: CompanyViewModel | undefined;

    constructor(data?: IInvoiceViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.amount = _data["amount"];
            this.vatAmount = _data["vatAmount"];
            this.number = _data["number"];
            this.currencySymbol = _data["currencySymbol"];
            this.documentId = _data["documentId"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KeyValuePairOfStringAndDouble.fromJS(item, _mappings));
            }
            this.notes = _data["notes"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.emittingCompany = _data["emittingCompany"] ? CompanyViewModel.fromJS(_data["emittingCompany"], _mappings) : <any>undefined;
            this.receivingCompany = _data["receivingCompany"] ? CompanyViewModel.fromJS(_data["receivingCompany"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): InvoiceViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<InvoiceViewModel>(data, _mappings, InvoiceViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["amount"] = this.amount;
        data["vatAmount"] = this.vatAmount;
        data["number"] = this.number;
        data["currencySymbol"] = this.currencySymbol;
        data["documentId"] = this.documentId;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["notes"] = this.notes;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["emittingCompany"] = this.emittingCompany ? this.emittingCompany.toJSON() : <any>undefined;
        data["receivingCompany"] = this.receivingCompany ? this.receivingCompany.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInvoiceViewModel {
    id: string | undefined;
    amount: number;
    vatAmount: number;
    number: number;
    currencySymbol: string | undefined;
    documentId: string | undefined;
    items: KeyValuePairOfStringAndDouble[] | undefined;
    notes: string | undefined;
    date: Date;
    emittingCompany: CompanyViewModel | undefined;
    receivingCompany: CompanyViewModel | undefined;
}

export class KeyValuePairOfStringAndDouble implements IKeyValuePairOfStringAndDouble {
    key!: string;
    value!: number;

    constructor(data?: IKeyValuePairOfStringAndDouble) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any, _mappings?: any): KeyValuePairOfStringAndDouble | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<KeyValuePairOfStringAndDouble>(data, _mappings, KeyValuePairOfStringAndDouble);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValuePairOfStringAndDouble {
    key: string;
    value: number;
}

export class CompanyViewModel implements ICompanyViewModel {
    id!: string | undefined;
    legalName!: string | undefined;
    tradingName!: string | undefined;
    registrationNumber!: string | undefined;
    phoneNumber!: string | undefined;
    emailAddress!: string | undefined;
    bankAccount!: BankAccountViewModel | undefined;
    registrationDocument!: DocumentViewModel | undefined;
    owners!: PersonViewModel[] | undefined;
    principalAddress!: AddressViewModel | undefined;
    registeredAddress!: AddressViewModel | undefined;

    constructor(data?: ICompanyViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.legalName = _data["legalName"];
            this.tradingName = _data["tradingName"];
            this.registrationNumber = _data["registrationNumber"];
            this.phoneNumber = _data["phoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.bankAccount = _data["bankAccount"] ? BankAccountViewModel.fromJS(_data["bankAccount"], _mappings) : <any>undefined;
            this.registrationDocument = _data["registrationDocument"] ? DocumentViewModel.fromJS(_data["registrationDocument"], _mappings) : <any>undefined;
            if (Array.isArray(_data["owners"])) {
                this.owners = [] as any;
                for (let item of _data["owners"])
                    this.owners!.push(PersonViewModel.fromJS(item, _mappings));
            }
            this.principalAddress = _data["principalAddress"] ? AddressViewModel.fromJS(_data["principalAddress"], _mappings) : <any>undefined;
            this.registeredAddress = _data["registeredAddress"] ? AddressViewModel.fromJS(_data["registeredAddress"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CompanyViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CompanyViewModel>(data, _mappings, CompanyViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["legalName"] = this.legalName;
        data["tradingName"] = this.tradingName;
        data["registrationNumber"] = this.registrationNumber;
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["bankAccount"] = this.bankAccount ? this.bankAccount.toJSON() : <any>undefined;
        data["registrationDocument"] = this.registrationDocument ? this.registrationDocument.toJSON() : <any>undefined;
        if (Array.isArray(this.owners)) {
            data["owners"] = [];
            for (let item of this.owners)
                data["owners"].push(item.toJSON());
        }
        data["principalAddress"] = this.principalAddress ? this.principalAddress.toJSON() : <any>undefined;
        data["registeredAddress"] = this.registeredAddress ? this.registeredAddress.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompanyViewModel {
    id: string | undefined;
    legalName: string | undefined;
    tradingName: string | undefined;
    registrationNumber: string | undefined;
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    bankAccount: BankAccountViewModel | undefined;
    registrationDocument: DocumentViewModel | undefined;
    owners: PersonViewModel[] | undefined;
    principalAddress: AddressViewModel | undefined;
    registeredAddress: AddressViewModel | undefined;
}

export class BankAccountViewModel implements IBankAccountViewModel {
    id!: string | undefined;
    bankAccountTypeId!: BankAccountTypeEnum;
    accountNumber!: string | undefined;
    bankCode!: string | undefined;
    branchCode!: string | undefined;
    iban!: string | undefined;
    bban!: string | undefined;
    swiftbic!: string | undefined;
    countryId!: CountryEnum;
    bankAccountHolder!: BankAccountHolderViewModel | undefined;

    constructor(data?: IBankAccountViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankAccountTypeId = _data["bankAccountTypeId"];
            this.accountNumber = _data["accountNumber"];
            this.bankCode = _data["bankCode"];
            this.branchCode = _data["branchCode"];
            this.iban = _data["iban"];
            this.bban = _data["bban"];
            this.swiftbic = _data["swiftbic"];
            this.countryId = _data["countryId"];
            this.bankAccountHolder = _data["bankAccountHolder"] ? BankAccountHolderViewModel.fromJS(_data["bankAccountHolder"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): BankAccountViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BankAccountViewModel>(data, _mappings, BankAccountViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAccountTypeId"] = this.bankAccountTypeId;
        data["accountNumber"] = this.accountNumber;
        data["bankCode"] = this.bankCode;
        data["branchCode"] = this.branchCode;
        data["iban"] = this.iban;
        data["bban"] = this.bban;
        data["swiftbic"] = this.swiftbic;
        data["countryId"] = this.countryId;
        data["bankAccountHolder"] = this.bankAccountHolder ? this.bankAccountHolder.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBankAccountViewModel {
    id: string | undefined;
    bankAccountTypeId: BankAccountTypeEnum;
    accountNumber: string | undefined;
    bankCode: string | undefined;
    branchCode: string | undefined;
    iban: string | undefined;
    bban: string | undefined;
    swiftbic: string | undefined;
    countryId: CountryEnum;
    bankAccountHolder: BankAccountHolderViewModel | undefined;
}

export enum BankAccountTypeEnum {
    Savings = 1,
    Current = 2,
    Cash = 3,
}

export enum CountryEnum {
    Afghanistan = 1,
    AlandIslands = 2,
    Albania = 3,
    Algeria = 4,
    AmericanSamoa = 5,
    Andorra = 6,
    Angola = 7,
    Anguilla = 8,
    Antarctica = 9,
    AntiguaAndBarbuda = 10,
    Argentina = 11,
    Armenia = 12,
    Aruba = 13,
    Australia = 14,
    Austria = 15,
    Azerbaijan = 16,
    Bahamas = 17,
    Bahrain = 18,
    Bangladesh = 19,
    Barbados = 20,
    Belarus = 21,
    Belgium = 22,
    Belize = 23,
    Benin = 24,
    Bermuda = 25,
    Bhutan = 26,
    BoliviaPlurinationalStateof = 27,
    BonaireSintEustatiusandSaba = 28,
    BosniaAndHerzegovina = 29,
    Botswana = 30,
    BouvetIsland = 31,
    Brazil = 32,
    BritishIndianOceanTerritory = 33,
    BruneiDarussalam = 34,
    Bulgaria = 35,
    BurkinaFaso = 36,
    Burundi = 37,
    Cambodia = 38,
    Cameroon = 39,
    Canada = 40,
    CapeVerde = 41,
    CaymanIslands = 42,
    CentralAfricanRepublic = 43,
    Chad = 44,
    Chile = 45,
    China = 46,
    ChristmasIsland = 47,
    CocosKeelingIslands = 48,
    Colombia = 49,
    Comoros = 50,
    Congo = 51,
    CongotheDemocraticRepublicofthe = 52,
    CookIslands = 53,
    CostaRica = 54,
    CtedIvoire = 55,
    Croatia = 56,
    Cuba = 57,
    Curaao = 58,
    Cyprus = 59,
    CzechRepublic = 60,
    Denmark = 61,
    Djibouti = 62,
    Dominica = 63,
    DominicanRepublic = 64,
    Ecuador = 65,
    Egypt = 66,
    ElSalvador = 67,
    EquatorialGuinea = 68,
    Eritrea = 69,
    Estonia = 70,
    Ethiopia = 71,
    FalklandIslands = 72,
    FaroeIslands = 73,
    Fiji = 74,
    Finland = 75,
    France = 76,
    FrenchGuiana = 77,
    FrenchPolynesia = 78,
    FrenchSouthernTerritories = 79,
    Gabon = 80,
    Gambia = 81,
    Georgia = 82,
    Germany = 83,
    Ghana = 84,
    Gibraltar = 85,
    Greece = 86,
    Greenland = 87,
    Grenada = 88,
    Guadeloupe = 89,
    Guam = 90,
    Guatemala = 91,
    Guernsey = 92,
    Guinea = 93,
    GuineaBissau = 94,
    Guyana = 95,
    Haiti = 96,
    HeardIslandAndMcDonaldIslands = 97,
    VaticanCityState = 98,
    Honduras = 99,
    HongKong = 100,
    Hungary = 101,
    Iceland = 102,
    India = 103,
    Indonesia = 104,
    Iran = 105,
    Iraq = 106,
    Ireland = 107,
    IsleofMan = 108,
    Israel = 109,
    Italy = 110,
    Jamaica = 111,
    Japan = 112,
    Jersey = 113,
    Jordan = 114,
    Kazakhstan = 115,
    Kenya = 116,
    Kiribati = 117,
    NorthKorea = 118,
    SouthKorea = 119,
    Kuwait = 120,
    Kyrgyzstan = 121,
    LaoPeoples = 122,
    Latvia = 123,
    Lebanon = 124,
    Lesotho = 125,
    Liberia = 126,
    Libya = 127,
    Liechtenstein = 128,
    Lithuania = 129,
    Luxembourg = 130,
    Macao = 131,
    Macedonia = 132,
    Madagascar = 133,
    Malawi = 134,
    Malaysia = 135,
    Maldives = 136,
    Mali = 137,
    Malta = 138,
    MarshallIslands = 139,
    Martinique = 140,
    Mauritania = 141,
    Mauritius = 142,
    Mayotte = 143,
    Mexico = 144,
    Micronesia = 145,
    Moldova = 146,
    Monaco = 147,
    Mongolia = 148,
    Montenegro = 149,
    Montserrat = 150,
    Morocco = 151,
    Mozambique = 152,
    Myanmar = 153,
    Namibia = 154,
    Nauru = 155,
    Nepal = 156,
    Netherlands = 157,
    NewCaledonia = 158,
    NewZealand = 159,
    Nicaragua = 160,
    Niger = 161,
    Nigeria = 162,
    Niue = 163,
    NorfolkIsland = 164,
    NorthernMarianaIslands = 165,
    Norway = 166,
    Oman = 167,
    Pakistan = 168,
    Palau = 169,
    Palestine = 170,
    Panama = 171,
    PapuaNewGuinea = 172,
    Paraguay = 173,
    Peru = 174,
    Philippines = 175,
    Pitcairn = 176,
    Poland = 177,
    Portugal = 178,
    PuertoRico = 179,
    Qatar = 180,
    Runion = 181,
    Romania = 182,
    RussianFederation = 183,
    Rwanda = 184,
    SaintBarthlemy = 185,
    SaintHelenaAscensionandTristandaCunha = 186,
    SaintKittsandNevis = 187,
    SaintLucia = 188,
    SaintMartinFrenchpart = 189,
    SaintPierreandMiquelon = 190,
    SaintVincentAndTheGrenadines = 191,
    Samoa = 192,
    SanMarino = 193,
    SaoTomeAndPrincipe = 194,
    SaudiArabia = 195,
    Senegal = 196,
    Serbia = 197,
    Seychelles = 198,
    SierraLeone = 199,
    Singapore = 200,
    SintMaartenDutchpart = 201,
    Slovakia = 202,
    Slovenia = 203,
    SolomonIslands = 204,
    Somalia = 205,
    SouthAfrica = 206,
    SouthGeorgiaAndSouthSandwichIslands = 207,
    SouthSudan = 208,
    Spain = 209,
    SriLanka = 210,
    Sudan = 211,
    Suriname = 212,
    SvalbardandJanMayen = 213,
    Swaziland = 214,
    Sweden = 215,
    Switzerland = 216,
    SyrianArabRepublic = 217,
    Taiwan = 218,
    Tajikistan = 219,
    Tanzania = 220,
    Thailand = 221,
    TimorLeste = 222,
    Togo = 223,
    Tokelau = 224,
    Tonga = 225,
    TrinidadAndTobago = 226,
    Tunisia = 227,
    Turkey = 228,
    Turkmenistan = 229,
    TurksandCaicosIslands = 230,
    Tuvalu = 231,
    Uganda = 232,
    Ukraine = 233,
    UnitedArabEmirates = 234,
    UnitedKingdom = 235,
    UnitedStates = 236,
    UnitedStatesMinorOutlyingIslands = 237,
    Uruguay = 238,
    Uzbekistan = 239,
    Vanuatu = 240,
    Venezuela = 241,
    VietNam = 242,
    VirginIslandsBritish = 243,
    VirginIslandsUS = 244,
    WallisandFutuna = 245,
    WesternSahara = 246,
    Yemen = 247,
    Zambia = 248,
    Zimbabwe = 249,
}

export class BankAccountHolderViewModel implements IBankAccountHolderViewModel {
    id!: string | undefined;
    taxId!: string | undefined;
    companyName!: string | undefined;
    billingAddress!: AddressViewModel | undefined;
    person!: PersonViewModel | undefined;

    constructor(data?: IBankAccountHolderViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.taxId = _data["taxId"];
            this.companyName = _data["companyName"];
            this.billingAddress = _data["billingAddress"] ? AddressViewModel.fromJS(_data["billingAddress"], _mappings) : <any>undefined;
            this.person = _data["person"] ? PersonViewModel.fromJS(_data["person"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): BankAccountHolderViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BankAccountHolderViewModel>(data, _mappings, BankAccountHolderViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["taxId"] = this.taxId;
        data["companyName"] = this.companyName;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBankAccountHolderViewModel {
    id: string | undefined;
    taxId: string | undefined;
    companyName: string | undefined;
    billingAddress: AddressViewModel | undefined;
    person: PersonViewModel | undefined;
}

export class AddressViewModel implements IAddressViewModel {
    id!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    postalCode!: string | undefined;
    countryId!: CountryEnum;

    constructor(data?: IAddressViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddressViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddressViewModel>(data, _mappings, AddressViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface IAddressViewModel {
    id: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    postalCode: string | undefined;
    countryId: CountryEnum;
}

export class PersonViewModel implements IPersonViewModel {
    id!: string | undefined;
    nickName!: string | undefined;
    firstName!: string | undefined;
    middleName!: string | undefined;
    lastName!: string | undefined;
    address!: AddressViewModel | undefined;
    email!: string | undefined;
    mobilePhoneNumber!: string | undefined;
    fixedPhoneNumber!: string | undefined;
    countryOfBirthId!: number | undefined;
    role!: string | undefined;
    birthDate!: Date | undefined;
    verificationDocument!: DocumentViewModel | undefined;

    constructor(data?: IPersonViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nickName = _data["nickName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.address = _data["address"] ? AddressViewModel.fromJS(_data["address"], _mappings) : <any>undefined;
            this.email = _data["email"];
            this.mobilePhoneNumber = _data["mobilePhoneNumber"];
            this.fixedPhoneNumber = _data["fixedPhoneNumber"];
            this.countryOfBirthId = _data["countryOfBirthId"];
            this.role = _data["role"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.verificationDocument = _data["verificationDocument"] ? DocumentViewModel.fromJS(_data["verificationDocument"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): PersonViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PersonViewModel>(data, _mappings, PersonViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nickName"] = this.nickName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["mobilePhoneNumber"] = this.mobilePhoneNumber;
        data["fixedPhoneNumber"] = this.fixedPhoneNumber;
        data["countryOfBirthId"] = this.countryOfBirthId;
        data["role"] = this.role;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["verificationDocument"] = this.verificationDocument ? this.verificationDocument.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPersonViewModel {
    id: string | undefined;
    nickName: string | undefined;
    firstName: string | undefined;
    middleName: string | undefined;
    lastName: string | undefined;
    address: AddressViewModel | undefined;
    email: string | undefined;
    mobilePhoneNumber: string | undefined;
    fixedPhoneNumber: string | undefined;
    countryOfBirthId: number | undefined;
    role: string | undefined;
    birthDate: Date | undefined;
    verificationDocument: DocumentViewModel | undefined;
}

export class DocumentViewModel implements IDocumentViewModel {
    id!: string | undefined;
    documentCode!: string | undefined;
    documentTypeId!: DocumentTypeEnum;
    documentStatusId!: DocumentStatusEnum;
    externalLink!: string | undefined;
    jsonContent!: string | undefined;
    notes!: string | undefined;
    documentDate!: Date;
    documentContent!: string | undefined;
    fileExtension!: string | undefined;

    constructor(data?: IDocumentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentCode = _data["documentCode"];
            this.documentTypeId = _data["documentTypeId"];
            this.documentStatusId = _data["documentStatusId"];
            this.externalLink = _data["externalLink"];
            this.jsonContent = _data["jsonContent"];
            this.notes = _data["notes"];
            this.documentDate = _data["documentDate"] ? new Date(_data["documentDate"].toString()) : <any>undefined;
            this.documentContent = _data["documentContent"];
            this.fileExtension = _data["fileExtension"];
        }
    }

    static fromJS(data: any, _mappings?: any): DocumentViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DocumentViewModel>(data, _mappings, DocumentViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentCode"] = this.documentCode;
        data["documentTypeId"] = this.documentTypeId;
        data["documentStatusId"] = this.documentStatusId;
        data["externalLink"] = this.externalLink;
        data["jsonContent"] = this.jsonContent;
        data["notes"] = this.notes;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["documentContent"] = this.documentContent;
        data["fileExtension"] = this.fileExtension;
        return data;
    }
}

export interface IDocumentViewModel {
    id: string | undefined;
    documentCode: string | undefined;
    documentTypeId: DocumentTypeEnum;
    documentStatusId: DocumentStatusEnum;
    externalLink: string | undefined;
    jsonContent: string | undefined;
    notes: string | undefined;
    documentDate: Date;
    documentContent: string | undefined;
    fileExtension: string | undefined;
}

export enum DocumentTypeEnum {
    PlatformInvoice = 1,
    DeliveryNote = 2,
    Ticket = 3,
    IdentityCard = 4,
    Passport = 5,
    DrivingLicense = 6,
    CitizenCard = 7,
    ResidencePermit = 8,
    BusinessIdentity = 9,
    BankIdentity = 10,
    InvoiceRefund = 11,
    ReturnInvoice = 12,
    ReturnDeliveryNote = 13,
    JobContract = 14,
    Invoice = 15,
}

export enum DocumentStatusEnum {
    Created = 1,
    Processing = 2,
    Closed = 3,
}

export class BaseSearchRequest implements IBaseSearchRequest {
    pageSize!: number | undefined;
    pageIdx!: number | undefined;

    constructor(data?: IBaseSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.pageIdx = _data["pageIdx"];
        }
    }

    static fromJS(data: any, _mappings?: any): BaseSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BaseSearchRequest>(data, _mappings, BaseSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["pageIdx"] = this.pageIdx;
        return data;
    }
}

export interface IBaseSearchRequest {
    pageSize: number | undefined;
    pageIdx: number | undefined;
}

export class AddPaymentMethodResponse implements IAddPaymentMethodResponse {
    transactionId!: string | undefined;
    challengeUrl!: string | undefined;

    constructor(data?: IAddPaymentMethodResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.challengeUrl = _data["challengeUrl"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddPaymentMethodResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddPaymentMethodResponse>(data, _mappings, AddPaymentMethodResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["challengeUrl"] = this.challengeUrl;
        return data;
    }
}

export interface IAddPaymentMethodResponse {
    transactionId: string | undefined;
    challengeUrl: string | undefined;
}

export class StorePlatformFeatureViewModel implements IStorePlatformFeatureViewModel {
    id!: string | undefined;
    platformFeatureTypeId!: PlatformFeatureTypeEnum;
    startAt!: Date | undefined;
    expireAt!: Date | undefined;
    renewAutomatically!: boolean;
    price!: number;
    renewalPrice!: number | undefined;
    hasTrial!: boolean;

    constructor(data?: IStorePlatformFeatureViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.platformFeatureTypeId = _data["platformFeatureTypeId"];
            this.startAt = _data["startAt"] ? new Date(_data["startAt"].toString()) : <any>undefined;
            this.expireAt = _data["expireAt"] ? new Date(_data["expireAt"].toString()) : <any>undefined;
            this.renewAutomatically = _data["renewAutomatically"];
            this.price = _data["price"];
            this.renewalPrice = _data["renewalPrice"];
            this.hasTrial = _data["hasTrial"];
        }
    }

    static fromJS(data: any, _mappings?: any): StorePlatformFeatureViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<StorePlatformFeatureViewModel>(data, _mappings, StorePlatformFeatureViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["platformFeatureTypeId"] = this.platformFeatureTypeId;
        data["startAt"] = this.startAt ? this.startAt.toISOString() : <any>undefined;
        data["expireAt"] = this.expireAt ? this.expireAt.toISOString() : <any>undefined;
        data["renewAutomatically"] = this.renewAutomatically;
        data["price"] = this.price;
        data["renewalPrice"] = this.renewalPrice;
        data["hasTrial"] = this.hasTrial;
        return data;
    }
}

export interface IStorePlatformFeatureViewModel {
    id: string | undefined;
    platformFeatureTypeId: PlatformFeatureTypeEnum;
    startAt: Date | undefined;
    expireAt: Date | undefined;
    renewAutomatically: boolean;
    price: number;
    renewalPrice: number | undefined;
    hasTrial: boolean;
}

export enum PlatformFeatureTypeEnum {
    DIGITAL_MENU = 1,
    VENUE_ORDERING = 2,
    VENUE_PAYMENT = 3,
    INVENTORY = 4,
    SHIFTS = 5,
    DOCUMENTS = 6,
    SUPPLIERS = 7,
    BOOKINGS = 8,
    MARGINS = 9,
    CRM = 10,
    QUEUE_MANAGEMENT = 11,
    CAMPAIGNS = 12,
    ONLINE_ORDERING = 13,
    CASHIER = 14,
}

export class BookingViewModel implements IBookingViewModel {
    id!: string | undefined;
    name!: string | undefined;
    surname!: string | undefined;
    email!: string | undefined;
    phoneNumber!: string | undefined;
    tableId!: string | undefined;
    guestNumber!: number;
    startDate!: Date;
    bookingStatusId!: BookingStatusEnum;
    endDate!: Date;
    notifyBy!: NotificationMediumTypeEnum[] | undefined;

    constructor(data?: IBookingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.tableId = _data["tableId"];
            this.guestNumber = _data["guestNumber"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.bookingStatusId = _data["bookingStatusId"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["notifyBy"])) {
                this.notifyBy = [] as any;
                for (let item of _data["notifyBy"])
                    this.notifyBy!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): BookingViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BookingViewModel>(data, _mappings, BookingViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["tableId"] = this.tableId;
        data["guestNumber"] = this.guestNumber;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["bookingStatusId"] = this.bookingStatusId;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.notifyBy)) {
            data["notifyBy"] = [];
            for (let item of this.notifyBy)
                data["notifyBy"].push(item);
        }
        return data;
    }
}

export interface IBookingViewModel {
    id: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    email: string | undefined;
    phoneNumber: string | undefined;
    tableId: string | undefined;
    guestNumber: number;
    startDate: Date;
    bookingStatusId: BookingStatusEnum;
    endDate: Date;
    notifyBy: NotificationMediumTypeEnum[] | undefined;
}

export enum BookingStatusEnum {
    Accepted = 1,
    Rejected = 2,
    Created = 3,
    CancelledByUser = 4,
    CancelledByRestaurant = 5,
    Rescheduled = 6,
}

export enum NotificationMediumTypeEnum {
    EMAIL = 1,
    SMS = 2,
    PUSH = 3,
}

export class CampaignViewModel implements ICampaignViewModel {
    id!: string | undefined;
    languageInfo!: { [key: string]: LanguageInfoViewModel; } | undefined;
    isEnabled!: boolean;
    ordersRequiredForVoucher!: number;
    daysValidity!: number | undefined;
    sendAfterHours!: number;
    campaignTypeId!: CampaignTypeEnum;
    activeFrom!: Date | undefined;
    expireAt!: Date | undefined;
    code!: string | undefined;
    applyAutomatically!: boolean;
    voucherTypeId!: number;
    minOrderAmount!: number | undefined;
    discount!: number | undefined;
    amount!: number | undefined;
    voucherUsageTypeId!: number;
    createdByPlatformUserId!: string | undefined;
    maxVouchers!: number | undefined;
    includeFees!: boolean;
    voucherRewardTypeEnumId!: VoucherRewardTypeEnum;
    campaignMenuItems!: string[] | undefined;

    constructor(data?: ICampaignViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["languageInfo"]) {
                this.languageInfo = {} as any;
                for (let key in _data["languageInfo"]) {
                    if (_data["languageInfo"].hasOwnProperty(key))
                        (<any>this.languageInfo)![key] = _data["languageInfo"][key] ? LanguageInfoViewModel.fromJS(_data["languageInfo"][key], _mappings) : new LanguageInfoViewModel();
                }
            }
            this.isEnabled = _data["isEnabled"];
            this.ordersRequiredForVoucher = _data["ordersRequiredForVoucher"];
            this.daysValidity = _data["daysValidity"];
            this.sendAfterHours = _data["sendAfterHours"];
            this.campaignTypeId = _data["campaignTypeId"];
            this.activeFrom = _data["activeFrom"] ? new Date(_data["activeFrom"].toString()) : <any>undefined;
            this.expireAt = _data["expireAt"] ? new Date(_data["expireAt"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.applyAutomatically = _data["applyAutomatically"];
            this.voucherTypeId = _data["voucherTypeId"];
            this.minOrderAmount = _data["minOrderAmount"];
            this.discount = _data["discount"];
            this.amount = _data["amount"];
            this.voucherUsageTypeId = _data["voucherUsageTypeId"];
            this.createdByPlatformUserId = _data["createdByPlatformUserId"];
            this.maxVouchers = _data["maxVouchers"];
            this.includeFees = _data["includeFees"];
            this.voucherRewardTypeEnumId = _data["voucherRewardTypeEnumId"];
            if (Array.isArray(_data["campaignMenuItems"])) {
                this.campaignMenuItems = [] as any;
                for (let item of _data["campaignMenuItems"])
                    this.campaignMenuItems!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CampaignViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CampaignViewModel>(data, _mappings, CampaignViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.languageInfo) {
            data["languageInfo"] = {};
            for (let key in this.languageInfo) {
                if (this.languageInfo.hasOwnProperty(key))
                    (<any>data["languageInfo"])[key] = this.languageInfo[key] ? this.languageInfo[key].toJSON() : <any>undefined;
            }
        }
        data["isEnabled"] = this.isEnabled;
        data["ordersRequiredForVoucher"] = this.ordersRequiredForVoucher;
        data["daysValidity"] = this.daysValidity;
        data["sendAfterHours"] = this.sendAfterHours;
        data["campaignTypeId"] = this.campaignTypeId;
        data["activeFrom"] = this.activeFrom ? this.activeFrom.toISOString() : <any>undefined;
        data["expireAt"] = this.expireAt ? this.expireAt.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["applyAutomatically"] = this.applyAutomatically;
        data["voucherTypeId"] = this.voucherTypeId;
        data["minOrderAmount"] = this.minOrderAmount;
        data["discount"] = this.discount;
        data["amount"] = this.amount;
        data["voucherUsageTypeId"] = this.voucherUsageTypeId;
        data["createdByPlatformUserId"] = this.createdByPlatformUserId;
        data["maxVouchers"] = this.maxVouchers;
        data["includeFees"] = this.includeFees;
        data["voucherRewardTypeEnumId"] = this.voucherRewardTypeEnumId;
        if (Array.isArray(this.campaignMenuItems)) {
            data["campaignMenuItems"] = [];
            for (let item of this.campaignMenuItems)
                data["campaignMenuItems"].push(item);
        }
        return data;
    }
}

export interface ICampaignViewModel {
    id: string | undefined;
    languageInfo: { [key: string]: LanguageInfoViewModel; } | undefined;
    isEnabled: boolean;
    ordersRequiredForVoucher: number;
    daysValidity: number | undefined;
    sendAfterHours: number;
    campaignTypeId: CampaignTypeEnum;
    activeFrom: Date | undefined;
    expireAt: Date | undefined;
    code: string | undefined;
    applyAutomatically: boolean;
    voucherTypeId: number;
    minOrderAmount: number | undefined;
    discount: number | undefined;
    amount: number | undefined;
    voucherUsageTypeId: number;
    createdByPlatformUserId: string | undefined;
    maxVouchers: number | undefined;
    includeFees: boolean;
    voucherRewardTypeEnumId: VoucherRewardTypeEnum;
    campaignMenuItems: string[] | undefined;
}

export class LanguageInfoViewModel implements ILanguageInfoViewModel {
    name!: string | undefined;
    description!: string | undefined;

    constructor(data?: ILanguageInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any, _mappings?: any): LanguageInfoViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LanguageInfoViewModel>(data, _mappings, LanguageInfoViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ILanguageInfoViewModel {
    name: string | undefined;
    description: string | undefined;
}

export enum CampaignTypeEnum {
    Acquisition = 1,
    Loyalty = 2,
    Retention = 3,
}

export enum VoucherRewardTypeEnum {
    FreeItem = 1,
    FreeMeal = 2,
    DiscountPercentage = 3,
    DiscountAmount = 4,
    FreeCredit = 5,
    TwoForOne = 6,
    FreeDelivery = 7,
    Cashback = 8,
    FreeEntrance = 9,
    FreeBundle = 10,
    Points = 11,
}

export class VoucherViewModel implements IVoucherViewModel {
    id!: string | undefined;
    code!: string | undefined;
    discountAmount!: number | undefined;
    discountPercentage!: number | undefined;
    minAmount!: number | undefined;
    reason!: string | undefined;
    maxCount!: number | undefined;
    isActive!: boolean;
    expireAt!: Date | undefined;
    rewardTypeId!: VoucherRewardTypeEnum;

    constructor(data?: IVoucherViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.discountAmount = _data["discountAmount"];
            this.discountPercentage = _data["discountPercentage"];
            this.minAmount = _data["minAmount"];
            this.reason = _data["reason"];
            this.maxCount = _data["maxCount"];
            this.isActive = _data["isActive"];
            this.expireAt = _data["expireAt"] ? new Date(_data["expireAt"].toString()) : <any>undefined;
            this.rewardTypeId = _data["rewardTypeId"];
        }
    }

    static fromJS(data: any, _mappings?: any): VoucherViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<VoucherViewModel>(data, _mappings, VoucherViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["discountAmount"] = this.discountAmount;
        data["discountPercentage"] = this.discountPercentage;
        data["minAmount"] = this.minAmount;
        data["reason"] = this.reason;
        data["maxCount"] = this.maxCount;
        data["isActive"] = this.isActive;
        data["expireAt"] = this.expireAt ? this.expireAt.toISOString() : <any>undefined;
        data["rewardTypeId"] = this.rewardTypeId;
        return data;
    }
}

export interface IVoucherViewModel {
    id: string | undefined;
    code: string | undefined;
    discountAmount: number | undefined;
    discountPercentage: number | undefined;
    minAmount: number | undefined;
    reason: string | undefined;
    maxCount: number | undefined;
    isActive: boolean;
    expireAt: Date | undefined;
    rewardTypeId: VoucherRewardTypeEnum;
}

export class CustomerViewModel implements ICustomerViewModel {
    id!: string | undefined;
    person!: PersonViewModel | undefined;
    company!: CompanyViewModel | undefined;
    notes!: string | undefined;

    constructor(data?: ICustomerViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.person = _data["person"] ? PersonViewModel.fromJS(_data["person"], _mappings) : <any>undefined;
            this.company = _data["company"] ? CompanyViewModel.fromJS(_data["company"], _mappings) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any, _mappings?: any): CustomerViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CustomerViewModel>(data, _mappings, CustomerViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICustomerViewModel {
    id: string | undefined;
    person: PersonViewModel | undefined;
    company: CompanyViewModel | undefined;
    notes: string | undefined;
}

export class PaginatedResultOfCustomerViewModel implements IPaginatedResultOfCustomerViewModel {
    items!: CustomerViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfCustomerViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfCustomerViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfCustomerViewModel>(data, _mappings, PaginatedResultOfCustomerViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfCustomerViewModel {
    items: CustomerViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class CustomerSearchRequest extends BaseSearchRequest implements ICustomerSearchRequest {
    fullName!: string | undefined;
    companyName!: string | undefined;
    phoneNumber!: string | undefined;
    email!: string | undefined;

    constructor(data?: ICustomerSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.fullName = _data["fullName"];
            this.companyName = _data["companyName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any, _mappings?: any): CustomerSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CustomerSearchRequest>(data, _mappings, CustomerSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["companyName"] = this.companyName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        super.toJSON(data);
        return data;
    }
}

export interface ICustomerSearchRequest extends IBaseSearchRequest {
    fullName: string | undefined;
    companyName: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
}

export class SelectOptionViewModel implements ISelectOptionViewModel {
    label!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISelectOptionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any, _mappings?: any): SelectOptionViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SelectOptionViewModel>(data, _mappings, SelectOptionViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface ISelectOptionViewModel {
    label: string | undefined;
    value: string | undefined;
}

export class ChartViewModel implements IChartViewModel {
    liveTitle!: string | undefined;
    liveValueKey!: string | undefined;
    title!: string | undefined;
    id!: string | undefined;
    type!: ChartViewTypeEnum;
    labels!: string[] | undefined;
    datasets!: { [key: string]: number[]; } | undefined;
    colors!: { [key: string]: string[]; } | undefined;

    constructor(data?: IChartViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.liveTitle = _data["liveTitle"];
            this.liveValueKey = _data["liveValueKey"];
            this.title = _data["title"];
            this.id = _data["id"];
            this.type = _data["type"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (_data["datasets"]) {
                this.datasets = {} as any;
                for (let key in _data["datasets"]) {
                    if (_data["datasets"].hasOwnProperty(key))
                        (<any>this.datasets)![key] = _data["datasets"][key] !== undefined ? _data["datasets"][key] : [];
                }
            }
            if (_data["colors"]) {
                this.colors = {} as any;
                for (let key in _data["colors"]) {
                    if (_data["colors"].hasOwnProperty(key))
                        (<any>this.colors)![key] = _data["colors"][key] !== undefined ? _data["colors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ChartViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChartViewModel>(data, _mappings, ChartViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["liveTitle"] = this.liveTitle;
        data["liveValueKey"] = this.liveValueKey;
        data["title"] = this.title;
        data["id"] = this.id;
        data["type"] = this.type;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (this.datasets) {
            data["datasets"] = {};
            for (let key in this.datasets) {
                if (this.datasets.hasOwnProperty(key))
                    (<any>data["datasets"])[key] = (<any>this.datasets)[key];
            }
        }
        if (this.colors) {
            data["colors"] = {};
            for (let key in this.colors) {
                if (this.colors.hasOwnProperty(key))
                    (<any>data["colors"])[key] = (<any>this.colors)[key];
            }
        }
        return data;
    }
}

export interface IChartViewModel {
    liveTitle: string | undefined;
    liveValueKey: string | undefined;
    title: string | undefined;
    id: string | undefined;
    type: ChartViewTypeEnum;
    labels: string[] | undefined;
    datasets: { [key: string]: number[]; } | undefined;
    colors: { [key: string]: string[]; } | undefined;
}

export enum ChartViewTypeEnum {
    Bar = 1,
    Line = 2,
}

export class DeviceViewModel implements IDeviceViewModel {
    id!: string | undefined;
    name!: string | undefined;
    deviceMachineId!: string | undefined;
    deviceToken!: string | undefined;
    restaurantId!: string | undefined;
    isEnabled!: boolean;
    createdAt!: Date;
    defaultPrinterId!: string | undefined;
    settings!: DeviceSettingsViewModel | undefined;

    constructor(data?: IDeviceViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.deviceMachineId = _data["deviceMachineId"];
            this.deviceToken = _data["deviceToken"];
            this.restaurantId = _data["restaurantId"];
            this.isEnabled = _data["isEnabled"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.defaultPrinterId = _data["defaultPrinterId"];
            this.settings = _data["settings"] ? DeviceSettingsViewModel.fromJS(_data["settings"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): DeviceViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeviceViewModel>(data, _mappings, DeviceViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["deviceMachineId"] = this.deviceMachineId;
        data["deviceToken"] = this.deviceToken;
        data["restaurantId"] = this.restaurantId;
        data["isEnabled"] = this.isEnabled;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["defaultPrinterId"] = this.defaultPrinterId;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDeviceViewModel {
    id: string | undefined;
    name: string | undefined;
    deviceMachineId: string | undefined;
    deviceToken: string | undefined;
    restaurantId: string | undefined;
    isEnabled: boolean;
    createdAt: Date;
    defaultPrinterId: string | undefined;
    settings: DeviceSettingsViewModel | undefined;
}

export class DeviceSettingsViewModel implements IDeviceSettingsViewModel {
    showScrollbarButtons!: boolean;
    automaticLogoutSeconds!: number | undefined;

    constructor(data?: IDeviceSettingsViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.showScrollbarButtons = _data["showScrollbarButtons"];
            this.automaticLogoutSeconds = _data["automaticLogoutSeconds"];
        }
    }

    static fromJS(data: any, _mappings?: any): DeviceSettingsViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeviceSettingsViewModel>(data, _mappings, DeviceSettingsViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showScrollbarButtons"] = this.showScrollbarButtons;
        data["automaticLogoutSeconds"] = this.automaticLogoutSeconds;
        return data;
    }
}

export interface IDeviceSettingsViewModel {
    showScrollbarButtons: boolean;
    automaticLogoutSeconds: number | undefined;
}

export class PrinterViewModel implements IPrinterViewModel {
    id!: string | undefined;
    name!: string | undefined;
    deviceId!: string | undefined;
    printerTypeId!: PrinterTypeEnum;
    ipAddress!: string | undefined;
    serialPortName!: string | undefined;
    serialFilePath!: string | undefined;
    baudRate!: number | undefined;
    isKitchenMode!: boolean;
    hasCashDrawer!: boolean;
    printerConnectionTypeId!: PrinterConnectionTypeEnum;
    size!: number | undefined;
    cashdrawerDefaultPin!: number | undefined;

    constructor(data?: IPrinterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.deviceId = _data["deviceId"];
            this.printerTypeId = _data["printerTypeId"];
            this.ipAddress = _data["ipAddress"];
            this.serialPortName = _data["serialPortName"];
            this.serialFilePath = _data["serialFilePath"];
            this.baudRate = _data["baudRate"];
            this.isKitchenMode = _data["isKitchenMode"];
            this.hasCashDrawer = _data["hasCashDrawer"];
            this.printerConnectionTypeId = _data["printerConnectionTypeId"];
            this.size = _data["size"];
            this.cashdrawerDefaultPin = _data["cashdrawerDefaultPin"];
        }
    }

    static fromJS(data: any, _mappings?: any): PrinterViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PrinterViewModel>(data, _mappings, PrinterViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["deviceId"] = this.deviceId;
        data["printerTypeId"] = this.printerTypeId;
        data["ipAddress"] = this.ipAddress;
        data["serialPortName"] = this.serialPortName;
        data["serialFilePath"] = this.serialFilePath;
        data["baudRate"] = this.baudRate;
        data["isKitchenMode"] = this.isKitchenMode;
        data["hasCashDrawer"] = this.hasCashDrawer;
        data["printerConnectionTypeId"] = this.printerConnectionTypeId;
        data["size"] = this.size;
        data["cashdrawerDefaultPin"] = this.cashdrawerDefaultPin;
        return data;
    }
}

export interface IPrinterViewModel {
    id: string | undefined;
    name: string | undefined;
    deviceId: string | undefined;
    printerTypeId: PrinterTypeEnum;
    ipAddress: string | undefined;
    serialPortName: string | undefined;
    serialFilePath: string | undefined;
    baudRate: number | undefined;
    isKitchenMode: boolean;
    hasCashDrawer: boolean;
    printerConnectionTypeId: PrinterConnectionTypeEnum;
    size: number | undefined;
    cashdrawerDefaultPin: number | undefined;
}

export enum PrinterTypeEnum {
    EscPos = 1,
    StarGraphic = 2,
    StarPRNT = 3,
    ZPL = 4,
    Usb = 5,
    EscPosMatrix = 6,
}

export enum PrinterConnectionTypeEnum {
    Network = 1,
    Serial = 2,
    File = 3,
    Samba = 4,
}

export class RestaurantDocumentViewModel implements IRestaurantDocumentViewModel {
    id!: string | undefined;
    name!: string | undefined;
    amount!: number | undefined;
    taxPercentage!: number | undefined;
    discountAmount!: number | undefined;
    notes!: string | undefined;
    restaurantId!: string | undefined;
    supplierId!: string | undefined;
    platformUserCreatorId!: string | undefined;
    document!: DocumentViewModel | undefined;
    categoryId!: string | undefined;

    constructor(data?: IRestaurantDocumentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.amount = _data["amount"];
            this.taxPercentage = _data["taxPercentage"];
            this.discountAmount = _data["discountAmount"];
            this.notes = _data["notes"];
            this.restaurantId = _data["restaurantId"];
            this.supplierId = _data["supplierId"];
            this.platformUserCreatorId = _data["platformUserCreatorId"];
            this.document = _data["document"] ? DocumentViewModel.fromJS(_data["document"], _mappings) : <any>undefined;
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any, _mappings?: any): RestaurantDocumentViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RestaurantDocumentViewModel>(data, _mappings, RestaurantDocumentViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["amount"] = this.amount;
        data["taxPercentage"] = this.taxPercentage;
        data["discountAmount"] = this.discountAmount;
        data["notes"] = this.notes;
        data["restaurantId"] = this.restaurantId;
        data["supplierId"] = this.supplierId;
        data["platformUserCreatorId"] = this.platformUserCreatorId;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["categoryId"] = this.categoryId;
        return data;
    }
}

export interface IRestaurantDocumentViewModel {
    id: string | undefined;
    name: string | undefined;
    amount: number | undefined;
    taxPercentage: number | undefined;
    discountAmount: number | undefined;
    notes: string | undefined;
    restaurantId: string | undefined;
    supplierId: string | undefined;
    platformUserCreatorId: string | undefined;
    document: DocumentViewModel | undefined;
    categoryId: string | undefined;
}

export class PaginatedResultOfRestaurantDocumentViewModel implements IPaginatedResultOfRestaurantDocumentViewModel {
    items!: RestaurantDocumentViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfRestaurantDocumentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RestaurantDocumentViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfRestaurantDocumentViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfRestaurantDocumentViewModel>(data, _mappings, PaginatedResultOfRestaurantDocumentViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfRestaurantDocumentViewModel {
    items: RestaurantDocumentViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class DocumentSearchRequest extends BaseSearchRequest implements IDocumentSearchRequest {
    dateFrom!: Date | undefined;
    dateTo!: Date | undefined;
    documentTypeId!: DocumentTypeEnum | undefined;

    constructor(data?: IDocumentSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
            this.documentTypeId = _data["documentTypeId"];
        }
    }

    static fromJS(data: any, _mappings?: any): DocumentSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DocumentSearchRequest>(data, _mappings, DocumentSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["documentTypeId"] = this.documentTypeId;
        super.toJSON(data);
        return data;
    }
}

export interface IDocumentSearchRequest extends IBaseSearchRequest {
    dateFrom: Date | undefined;
    dateTo: Date | undefined;
    documentTypeId: DocumentTypeEnum | undefined;
}

export class Language implements ILanguage {
    code!: string;
    name!: string;

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): Language | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Language>(data, _mappings, Language);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface ILanguage {
    code: string;
    name: string;
}

export class LegalAgreementViewModel implements ILegalAgreementViewModel {
    id!: string | undefined;
    countryId!: CountryEnum;
    version!: number;
    parentAgreementId!: string | undefined;
    publishedAt!: Date | undefined;
    createdAt!: Date;
    languageInfos!: { [key: string]: LanguageInfoViewModel; } | undefined;

    constructor(data?: ILegalAgreementViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryId = _data["countryId"];
            this.version = _data["version"];
            this.parentAgreementId = _data["parentAgreementId"];
            this.publishedAt = _data["publishedAt"] ? new Date(_data["publishedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (_data["languageInfos"]) {
                this.languageInfos = {} as any;
                for (let key in _data["languageInfos"]) {
                    if (_data["languageInfos"].hasOwnProperty(key))
                        (<any>this.languageInfos)![key] = _data["languageInfos"][key] ? LanguageInfoViewModel.fromJS(_data["languageInfos"][key], _mappings) : new LanguageInfoViewModel();
                }
            }
        }
    }

    static fromJS(data: any, _mappings?: any): LegalAgreementViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LegalAgreementViewModel>(data, _mappings, LegalAgreementViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryId"] = this.countryId;
        data["version"] = this.version;
        data["parentAgreementId"] = this.parentAgreementId;
        data["publishedAt"] = this.publishedAt ? this.publishedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (this.languageInfos) {
            data["languageInfos"] = {};
            for (let key in this.languageInfos) {
                if (this.languageInfos.hasOwnProperty(key))
                    (<any>data["languageInfos"])[key] = this.languageInfos[key] ? this.languageInfos[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface ILegalAgreementViewModel {
    id: string | undefined;
    countryId: CountryEnum;
    version: number;
    parentAgreementId: string | undefined;
    publishedAt: Date | undefined;
    createdAt: Date;
    languageInfos: { [key: string]: LanguageInfoViewModel; } | undefined;
}

export enum TransactionStatusEnum {
    Created = 1,
    Processing = 2,
    Hold = 3,
    Succeed = 4,
    Failed = 5,
    Canceled = 6,
    Refunded = 7,
    PartiallyRefunded = 8,
}

export class PaginatedResultOfActivityLogViewModel implements IPaginatedResultOfActivityLogViewModel {
    items!: ActivityLogViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfActivityLogViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActivityLogViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfActivityLogViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfActivityLogViewModel>(data, _mappings, PaginatedResultOfActivityLogViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfActivityLogViewModel {
    items: ActivityLogViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class ActivityLogViewModel implements IActivityLogViewModel {
    id!: string | undefined;
    restaurantSlug!: string | undefined;
    platformUserName!: string | undefined;
    relatedEntityId!: string | undefined;
    jsonParams!: string | undefined;
    platformOperationTypeId!: PlatformOperationTypeEnum;
    createdAt!: Date;

    constructor(data?: IActivityLogViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.restaurantSlug = _data["restaurantSlug"];
            this.platformUserName = _data["platformUserName"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.jsonParams = _data["jsonParams"];
            this.platformOperationTypeId = _data["platformOperationTypeId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ActivityLogViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ActivityLogViewModel>(data, _mappings, ActivityLogViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["restaurantSlug"] = this.restaurantSlug;
        data["platformUserName"] = this.platformUserName;
        data["relatedEntityId"] = this.relatedEntityId;
        data["jsonParams"] = this.jsonParams;
        data["platformOperationTypeId"] = this.platformOperationTypeId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IActivityLogViewModel {
    id: string | undefined;
    restaurantSlug: string | undefined;
    platformUserName: string | undefined;
    relatedEntityId: string | undefined;
    jsonParams: string | undefined;
    platformOperationTypeId: PlatformOperationTypeEnum;
    createdAt: Date;
}

export enum PlatformOperationTypeEnum {
    STORE_CREATE = 1,
    STORE_UPDATE = 2,
    USER_CREATE = 3,
    USER_UPDATE = 4,
    USER_DELETE = 5,
    CATALOG_CREATE = 6,
    CATALOG_UPDATE = 7,
    CATALOG_DELETE = 8,
    TABLE_GROUP_CREATE = 10,
    TABLE_GROUP_UPDATE = 11,
    TABLE_GROUP_DELETE = 12,
    ORDER_UPDATE = 13,
    ORDER_REFUND = 14,
    ORDER_PRINT = 15,
    CAMPAIGN_CREATE = 16,
    CAMPAIGN_UPDATE = 17,
    DEVICE_CREATE = 18,
    DEVICE_UPDATE = 19,
    DEVICE_DELETE = 20,
    DEVICE_BIND = 21,
    PRINTER_CREATE = 22,
    PRINTER_UPDATE = 23,
    PRINTER_DELETE = 24,
    MANUAL_TRANSACTION_CREATE = 25,
    ORDERS_ACCOUNT_PRINT = 26,
    NOTIFICATION_READ = 27,
    USER_LOGIN = 28,
    DEVICE_LOGIN = 29,
    USER_SETTINGS_CHANGE = 30,
    USER_PASSWORD_CHANGE = 31,
    USER_AUTHENTICATOR_TOGGLE = 32,
    USER_PIN_CHANGE = 33,
    ORDER_TYPE_STATUS_UPDATED = 34,
    SUPPLIER_CREATE = 35,
    SUPPLIER_UPDATE = 36,
    SUPPLIER_DELETE = 37,
    CAMPAIGN_DELETE = 38,
    VOUCHER_CREATE = 39,
    VOUCHER_UPDATE = 40,
    VOUCHER_DELETE = 41,
    INVOICE_GENERATED = 42,
    DOCUMENT_DOWNLOADED = 43,
    INVENTORY_PRODUCT_CREATE = 44,
    INVENTORY_PRODUCT_UPDATE = 45,
    INVENTORY_PRODUCT_CATEGORY_CREATE = 46,
    INVENTORY_PRODUCT_CATEGORY_UPDATE = 47,
    DOCUMENT_UPLOADED = 48,
    BOOKING_CREATE = 49,
    BOOKING_UPDATE = 50,
    BOOKING_DELETE = 51,
    BOOKING_STATUS_UPDATE = 52,
    INVENTORY_PRODUCT_CATEGORY_DELETE = 53,
    INVENTORY_PRODUCT_DELETE = 54,
    INVENTORY_PRODUCT_STOCK_RECORD_ADDED = 55,
    CASHBOX_DELETE = 56,
    CASHBOX_CREATE = 57,
    CASHBOX_UPDATE = 58,
    RECEIPT_REFUND = 59,
    RECEIPT_PAYMENT_METHOD_UPDATE = 60,
    CASHTAKING_CLOSE = 61,
    CASHTAKING_OPEN = 62,
    MANUAL_INTERNAL_TRANSACTION_CREATE = 63,
    MANUAL_INTERNAL_TRANSACTION_UPDATE = 64,
    ORDERS_ACCOUNT_TABLE_CHANGE = 65,
    ORDERS_ACCOUNT_MODIFIER_UPDATE = 66,
    ORDERS_ACCOUNT_SESSION_REJECTED = 67,
    ORDERS_ACCOUNT_SESSION_APPROVED = 68,
    ORDER_CREATED = 69,
    ORDERS_ACCOUNT_REFUND = 70,
    CATALOG_ITEM_VISIBILITY_UPDATE = 71,
    RECEIPT_CUSTOMER_UPDATE = 72,
    CUSTOMER_CREATE = 73,
    CUSTOMER_UPDATE = 74,
    CUSTOMER_DELETE = 75,
    CATALOG_CATEGORY_VISIBILITY_UPDATE = 76,
    DOCUMENT_CREATED = 77,
    CASHBOX_OPEN = 78,
    TABLE_AUTO_JOIN_UPDATE = 79,
    FEATURE_TOGGLE = 80,
    PAYMENT_METHOD_CREATE = 81,
    PAYMENT_METHOD_DELETE = 82,
    PAYMENT_METHOD_SET_DEFAULT = 83,
    BILLING_PAYMENT = 84,
    PRICING_UPDATED = 85,
    CASHTAKING_PRINT = 86,
    RECEIPT_PRINT = 87,
    END_OF_PERIOD_REPORT_PRINT = 88,
    BILLING_DELETED = 89,
    MANUAL_BILLING_PAYMENT = 90,
    ORDER_DELIVERY_STATUS_UPDATE = 91,
}

export class ActivityLogSearchRequest extends BaseSearchRequest implements IActivityLogSearchRequest {
    restaurantId!: string | undefined;
    platformUserId!: string | undefined;
    relatedEntityId!: string | undefined;
    operationTypeId!: PlatformOperationTypeEnum | undefined;
    dateFrom!: Date | undefined;
    dateTo!: Date | undefined;

    constructor(data?: IActivityLogSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.restaurantId = _data["restaurantId"];
            this.platformUserId = _data["platformUserId"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.operationTypeId = _data["operationTypeId"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ActivityLogSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ActivityLogSearchRequest>(data, _mappings, ActivityLogSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["restaurantId"] = this.restaurantId;
        data["platformUserId"] = this.platformUserId;
        data["relatedEntityId"] = this.relatedEntityId;
        data["operationTypeId"] = this.operationTypeId;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IActivityLogSearchRequest extends IBaseSearchRequest {
    restaurantId: string | undefined;
    platformUserId: string | undefined;
    relatedEntityId: string | undefined;
    operationTypeId: PlatformOperationTypeEnum | undefined;
    dateFrom: Date | undefined;
    dateTo: Date | undefined;
}

export class RoleViewModel implements IRoleViewModel {
    id!: string | undefined;
    name!: string | undefined;
    permissions!: PlatformPermissionEnum[];

    constructor(data?: IRoleViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissions = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): RoleViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RoleViewModel>(data, _mappings, RoleViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IRoleViewModel {
    id: string | undefined;
    name: string | undefined;
    permissions: PlatformPermissionEnum[];
}

export enum PlatformPermissionEnum {
    SuperAdmin = 1,
    Admin = 2,
    CreateStore = 3,
    ViewReports = 4,
    ManageStore = 5,
    ManageCatalog = 6,
    ViewOrders = 7,
    HandleOrders = 8,
    CollectPayment = 9,
    RefundPayment = 10,
    ManageCampaign = 11,
    CreateVoucher = 12,
    ViewDocuments = 13,
    ManageVouchers = 14,
    ManageInventory = 15,
    CreateSupplier = 16,
    ManageSupplier = 17,
    ManageBooking = 18,
    DeliverOrder = 19,
}

export class PlatformFeatureViewModel implements IPlatformFeatureViewModel {
    annualPrice!: number;
    monthlyPrice!: number;
    platformFeatureTypeEnumId!: PlatformFeatureTypeEnum;

    constructor(data?: IPlatformFeatureViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.annualPrice = _data["annualPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.platformFeatureTypeEnumId = _data["platformFeatureTypeEnumId"];
        }
    }

    static fromJS(data: any, _mappings?: any): PlatformFeatureViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PlatformFeatureViewModel>(data, _mappings, PlatformFeatureViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["annualPrice"] = this.annualPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["platformFeatureTypeEnumId"] = this.platformFeatureTypeEnumId;
        return data;
    }
}

export interface IPlatformFeatureViewModel {
    annualPrice: number;
    monthlyPrice: number;
    platformFeatureTypeEnumId: PlatformFeatureTypeEnum;
}

export class InventoryProductListItemViewModel implements IInventoryProductListItemViewModel {
    id!: string | undefined;
    lastPrice!: number | undefined;
    currentQuantity!: number;
    wastePercentage!: number;
    product!: SupplierProductViewModel | undefined;

    constructor(data?: IInventoryProductListItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lastPrice = _data["lastPrice"];
            this.currentQuantity = _data["currentQuantity"];
            this.wastePercentage = _data["wastePercentage"];
            this.product = _data["product"] ? SupplierProductViewModel.fromJS(_data["product"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): InventoryProductListItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<InventoryProductListItemViewModel>(data, _mappings, InventoryProductListItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lastPrice"] = this.lastPrice;
        data["currentQuantity"] = this.currentQuantity;
        data["wastePercentage"] = this.wastePercentage;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInventoryProductListItemViewModel {
    id: string | undefined;
    lastPrice: number | undefined;
    currentQuantity: number;
    wastePercentage: number;
    product: SupplierProductViewModel | undefined;
}

export class SupplierProductViewModel implements ISupplierProductViewModel {
    id!: string | undefined;
    supplierProductCategoryId!: string | undefined;
    name!: string | undefined;
    supplierId!: string | undefined;
    sku!: string | undefined;
    description!: string | undefined;
    minOrder!: number;
    taxPercentage!: number;
    price!: number;
    productMeasureUnitTypeId!: ProductMeasureUnitTypeEnum;
    isVisible!: boolean;

    constructor(data?: ISupplierProductViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.supplierProductCategoryId = _data["supplierProductCategoryId"];
            this.name = _data["name"];
            this.supplierId = _data["supplierId"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.minOrder = _data["minOrder"];
            this.taxPercentage = _data["taxPercentage"];
            this.price = _data["price"];
            this.productMeasureUnitTypeId = _data["productMeasureUnitTypeId"];
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any, _mappings?: any): SupplierProductViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SupplierProductViewModel>(data, _mappings, SupplierProductViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["supplierProductCategoryId"] = this.supplierProductCategoryId;
        data["name"] = this.name;
        data["supplierId"] = this.supplierId;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["minOrder"] = this.minOrder;
        data["taxPercentage"] = this.taxPercentage;
        data["price"] = this.price;
        data["productMeasureUnitTypeId"] = this.productMeasureUnitTypeId;
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface ISupplierProductViewModel {
    id: string | undefined;
    supplierProductCategoryId: string | undefined;
    name: string | undefined;
    supplierId: string | undefined;
    sku: string | undefined;
    description: string | undefined;
    minOrder: number;
    taxPercentage: number;
    price: number;
    productMeasureUnitTypeId: ProductMeasureUnitTypeEnum;
    isVisible: boolean;
}

export enum ProductMeasureUnitTypeEnum {
    Unit = 1,
    Kg = 2,
    Grams = 3,
    Milligrams = 4,
    Litres = 5,
    Centilitres = 6,
    Millilitres = 7,
    Ounce = 8,
    Pound = 9,
    Box = 10,
    Spoons = 11,
    Can = 12,
}

export class InventoryProductViewModel extends InventoryProductListItemViewModel implements IInventoryProductViewModel {
    categoryId!: string | undefined;
    alertAtQuantity!: number | undefined;
    referencePrice!: number;
    menuItems!: ItemInventoryProductViewModel[] | undefined;

    constructor(data?: IInventoryProductViewModel) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.alertAtQuantity = _data["alertAtQuantity"];
            this.referencePrice = _data["referencePrice"];
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(ItemInventoryProductViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): InventoryProductViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<InventoryProductViewModel>(data, _mappings, InventoryProductViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["alertAtQuantity"] = this.alertAtQuantity;
        data["referencePrice"] = this.referencePrice;
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInventoryProductViewModel extends IInventoryProductListItemViewModel {
    categoryId: string | undefined;
    alertAtQuantity: number | undefined;
    referencePrice: number;
    menuItems: ItemInventoryProductViewModel[] | undefined;
}

export class ItemInventoryProductViewModel implements IItemInventoryProductViewModel {
    id!: string | undefined;
    quantity!: number;
    netWaste!: number | undefined;
    wastePercentage!: number | undefined;
    errorPercentage!: number | undefined;

    constructor(data?: IItemInventoryProductViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
            this.netWaste = _data["netWaste"];
            this.wastePercentage = _data["wastePercentage"];
            this.errorPercentage = _data["errorPercentage"];
        }
    }

    static fromJS(data: any, _mappings?: any): ItemInventoryProductViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ItemInventoryProductViewModel>(data, _mappings, ItemInventoryProductViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["netWaste"] = this.netWaste;
        data["wastePercentage"] = this.wastePercentage;
        data["errorPercentage"] = this.errorPercentage;
        return data;
    }
}

export interface IItemInventoryProductViewModel {
    id: string | undefined;
    quantity: number;
    netWaste: number | undefined;
    wastePercentage: number | undefined;
    errorPercentage: number | undefined;
}

export class PaginatedResultOfInventoryProductStockRecordViewModel implements IPaginatedResultOfInventoryProductStockRecordViewModel {
    items!: InventoryProductStockRecordViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfInventoryProductStockRecordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InventoryProductStockRecordViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfInventoryProductStockRecordViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfInventoryProductStockRecordViewModel>(data, _mappings, PaginatedResultOfInventoryProductStockRecordViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfInventoryProductStockRecordViewModel {
    items: InventoryProductStockRecordViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class InventoryProductStockRecordViewModel implements IInventoryProductStockRecordViewModel {
    id!: string | undefined;
    inventoryProductId!: string | undefined;
    supplierOrderItemId!: string | undefined;
    orderItemId!: string | undefined;
    orderItemAttributeId!: string | undefined;
    quantity!: number;
    convertedQuantity!: number | undefined;
    errorPercentage!: number | undefined;
    notes!: string | undefined;
    productMeasureUnitTypeId!: ProductMeasureUnitTypeEnum | undefined;
    inventoryProductStockRecordTypeId!: InventoryProductStockRecordTypeEnum;
    documentId!: string | undefined;
    deliveredAt!: Date | undefined;
    createdAt!: Date;

    constructor(data?: IInventoryProductStockRecordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.inventoryProductId = _data["inventoryProductId"];
            this.supplierOrderItemId = _data["supplierOrderItemId"];
            this.orderItemId = _data["orderItemId"];
            this.orderItemAttributeId = _data["orderItemAttributeId"];
            this.quantity = _data["quantity"];
            this.convertedQuantity = _data["convertedQuantity"];
            this.errorPercentage = _data["errorPercentage"];
            this.notes = _data["notes"];
            this.productMeasureUnitTypeId = _data["productMeasureUnitTypeId"];
            this.inventoryProductStockRecordTypeId = _data["inventoryProductStockRecordTypeId"];
            this.documentId = _data["documentId"];
            this.deliveredAt = _data["deliveredAt"] ? new Date(_data["deliveredAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): InventoryProductStockRecordViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<InventoryProductStockRecordViewModel>(data, _mappings, InventoryProductStockRecordViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["inventoryProductId"] = this.inventoryProductId;
        data["supplierOrderItemId"] = this.supplierOrderItemId;
        data["orderItemId"] = this.orderItemId;
        data["orderItemAttributeId"] = this.orderItemAttributeId;
        data["quantity"] = this.quantity;
        data["convertedQuantity"] = this.convertedQuantity;
        data["errorPercentage"] = this.errorPercentage;
        data["notes"] = this.notes;
        data["productMeasureUnitTypeId"] = this.productMeasureUnitTypeId;
        data["inventoryProductStockRecordTypeId"] = this.inventoryProductStockRecordTypeId;
        data["documentId"] = this.documentId;
        data["deliveredAt"] = this.deliveredAt ? this.deliveredAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IInventoryProductStockRecordViewModel {
    id: string | undefined;
    inventoryProductId: string | undefined;
    supplierOrderItemId: string | undefined;
    orderItemId: string | undefined;
    orderItemAttributeId: string | undefined;
    quantity: number;
    convertedQuantity: number | undefined;
    errorPercentage: number | undefined;
    notes: string | undefined;
    productMeasureUnitTypeId: ProductMeasureUnitTypeEnum | undefined;
    inventoryProductStockRecordTypeId: InventoryProductStockRecordTypeEnum;
    documentId: string | undefined;
    deliveredAt: Date | undefined;
    createdAt: Date;
}

export enum InventoryProductStockRecordTypeEnum {
    ORDER = 1,
    SUPPLIER = 2,
    MANUAL = 3,
    EXPIRED = 4,
    LOST = 5,
    WASTE = 6,
}

export class InventoryProductCategoryViewModel implements IInventoryProductCategoryViewModel {
    id!: string | undefined;
    name!: string | undefined;
    colorCode!: string | undefined;
    lightText!: boolean;
    products!: InventoryProductViewModel[] | undefined;

    constructor(data?: IInventoryProductCategoryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.colorCode = _data["colorCode"];
            this.lightText = _data["lightText"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(InventoryProductViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): InventoryProductCategoryViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<InventoryProductCategoryViewModel>(data, _mappings, InventoryProductCategoryViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["colorCode"] = this.colorCode;
        data["lightText"] = this.lightText;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInventoryProductCategoryViewModel {
    id: string | undefined;
    name: string | undefined;
    colorCode: string | undefined;
    lightText: boolean;
    products: InventoryProductViewModel[] | undefined;
}

export class PaginatedResultOfInventoryProductViewModel implements IPaginatedResultOfInventoryProductViewModel {
    items!: InventoryProductViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfInventoryProductViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InventoryProductViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfInventoryProductViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfInventoryProductViewModel>(data, _mappings, PaginatedResultOfInventoryProductViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfInventoryProductViewModel {
    items: InventoryProductViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class InventoryProductSearchRequest extends BaseSearchRequest implements IInventoryProductSearchRequest {
    categoryId!: string | undefined;
    supplierId!: string | undefined;

    constructor(data?: IInventoryProductSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.supplierId = _data["supplierId"];
        }
    }

    static fromJS(data: any, _mappings?: any): InventoryProductSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<InventoryProductSearchRequest>(data, _mappings, InventoryProductSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["supplierId"] = this.supplierId;
        super.toJSON(data);
        return data;
    }
}

export interface IInventoryProductSearchRequest extends IBaseSearchRequest {
    categoryId: string | undefined;
    supplierId: string | undefined;
}

export class InventoryProductSelectOptionViewModel extends SelectOptionViewModel implements IInventoryProductSelectOptionViewModel {
    productMeasureUnitTypeId!: ProductMeasureUnitTypeEnum;

    constructor(data?: IInventoryProductSelectOptionViewModel) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.productMeasureUnitTypeId = _data["productMeasureUnitTypeId"];
        }
    }

    static fromJS(data: any, _mappings?: any): InventoryProductSelectOptionViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<InventoryProductSelectOptionViewModel>(data, _mappings, InventoryProductSelectOptionViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productMeasureUnitTypeId"] = this.productMeasureUnitTypeId;
        super.toJSON(data);
        return data;
    }
}

export interface IInventoryProductSelectOptionViewModel extends ISelectOptionViewModel {
    productMeasureUnitTypeId: ProductMeasureUnitTypeEnum;
}

export class MenuViewModel implements IMenuViewModel {
    id!: string | undefined;
    price!: number | undefined;
    languageInfo!: { [key: string]: LanguageInfoViewModel; };
    categories!: MenuCategoryViewModel[];
    imageUrl!: string | undefined;
    isActive!: boolean;
    isLocked!: boolean;
    isFixedPrice!: boolean;
    taxPercentage!: number | undefined;
    restaurantId!: string;
    createdAt!: Date;
    updatedAt!: Date;
    languages!: { [key: string]: boolean; };
    attributeGroups!: MenuAttributeGroupViewModel[];
    menuItems!: MenuItemViewModel[];
    attributes!: MenuAttributeItemViewModel[];
    suggestedItems!: string[];
    bundles!: MenuBundleViewModel[];

    constructor(data?: IMenuViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.languageInfo = {};
            this.categories = [];
            this.languages = {};
            this.attributeGroups = [];
            this.menuItems = [];
            this.attributes = [];
            this.suggestedItems = [];
            this.bundles = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            if (_data["languageInfo"]) {
                this.languageInfo = {} as any;
                for (let key in _data["languageInfo"]) {
                    if (_data["languageInfo"].hasOwnProperty(key))
                        (<any>this.languageInfo)![key] = _data["languageInfo"][key] ? LanguageInfoViewModel.fromJS(_data["languageInfo"][key], _mappings) : new LanguageInfoViewModel();
                }
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(MenuCategoryViewModel.fromJS(item, _mappings));
            }
            this.imageUrl = _data["imageUrl"];
            this.isActive = _data["isActive"];
            this.isLocked = _data["isLocked"];
            this.isFixedPrice = _data["isFixedPrice"];
            this.taxPercentage = _data["taxPercentage"];
            this.restaurantId = _data["restaurantId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (_data["languages"]) {
                this.languages = {} as any;
                for (let key in _data["languages"]) {
                    if (_data["languages"].hasOwnProperty(key))
                        (<any>this.languages)![key] = _data["languages"][key];
                }
            }
            if (Array.isArray(_data["attributeGroups"])) {
                this.attributeGroups = [] as any;
                for (let item of _data["attributeGroups"])
                    this.attributeGroups!.push(MenuAttributeGroupViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(MenuItemViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(MenuAttributeItemViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["suggestedItems"])) {
                this.suggestedItems = [] as any;
                for (let item of _data["suggestedItems"])
                    this.suggestedItems!.push(item);
            }
            if (Array.isArray(_data["bundles"])) {
                this.bundles = [] as any;
                for (let item of _data["bundles"])
                    this.bundles!.push(MenuBundleViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MenuViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuViewModel>(data, _mappings, MenuViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        if (this.languageInfo) {
            data["languageInfo"] = {};
            for (let key in this.languageInfo) {
                if (this.languageInfo.hasOwnProperty(key))
                    (<any>data["languageInfo"])[key] = this.languageInfo[key] ? this.languageInfo[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["imageUrl"] = this.imageUrl;
        data["isActive"] = this.isActive;
        data["isLocked"] = this.isLocked;
        data["isFixedPrice"] = this.isFixedPrice;
        data["taxPercentage"] = this.taxPercentage;
        data["restaurantId"] = this.restaurantId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (this.languages) {
            data["languages"] = {};
            for (let key in this.languages) {
                if (this.languages.hasOwnProperty(key))
                    (<any>data["languages"])[key] = (<any>this.languages)[key];
            }
        }
        if (Array.isArray(this.attributeGroups)) {
            data["attributeGroups"] = [];
            for (let item of this.attributeGroups)
                data["attributeGroups"].push(item.toJSON());
        }
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (Array.isArray(this.suggestedItems)) {
            data["suggestedItems"] = [];
            for (let item of this.suggestedItems)
                data["suggestedItems"].push(item);
        }
        if (Array.isArray(this.bundles)) {
            data["bundles"] = [];
            for (let item of this.bundles)
                data["bundles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuViewModel {
    id: string | undefined;
    price: number | undefined;
    languageInfo: { [key: string]: LanguageInfoViewModel; };
    categories: MenuCategoryViewModel[];
    imageUrl: string | undefined;
    isActive: boolean;
    isLocked: boolean;
    isFixedPrice: boolean;
    taxPercentage: number | undefined;
    restaurantId: string;
    createdAt: Date;
    updatedAt: Date;
    languages: { [key: string]: boolean; };
    attributeGroups: MenuAttributeGroupViewModel[];
    menuItems: MenuItemViewModel[];
    attributes: MenuAttributeItemViewModel[];
    suggestedItems: string[];
    bundles: MenuBundleViewModel[];
}

export class MenuCategoryViewModel implements IMenuCategoryViewModel {
    id!: string | undefined;
    languageInfo!: { [key: string]: LanguageInfoViewModel; };
    imageUrl!: string | undefined;
    isVisible!: boolean;
    createdAt!: Date;
    taxPercentage!: number | undefined;
    menuItemIds!: string[] | undefined;
    bundleId!: string | undefined;
    schedules!: VisibilityScheduleViewModel[] | undefined;

    constructor(data?: IMenuCategoryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.languageInfo = {};
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["languageInfo"]) {
                this.languageInfo = {} as any;
                for (let key in _data["languageInfo"]) {
                    if (_data["languageInfo"].hasOwnProperty(key))
                        (<any>this.languageInfo)![key] = _data["languageInfo"][key] ? LanguageInfoViewModel.fromJS(_data["languageInfo"][key], _mappings) : new LanguageInfoViewModel();
                }
            }
            this.imageUrl = _data["imageUrl"];
            this.isVisible = _data["isVisible"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.taxPercentage = _data["taxPercentage"];
            if (Array.isArray(_data["menuItemIds"])) {
                this.menuItemIds = [] as any;
                for (let item of _data["menuItemIds"])
                    this.menuItemIds!.push(item);
            }
            this.bundleId = _data["bundleId"];
            if (Array.isArray(_data["schedules"])) {
                this.schedules = [] as any;
                for (let item of _data["schedules"])
                    this.schedules!.push(VisibilityScheduleViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MenuCategoryViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuCategoryViewModel>(data, _mappings, MenuCategoryViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.languageInfo) {
            data["languageInfo"] = {};
            for (let key in this.languageInfo) {
                if (this.languageInfo.hasOwnProperty(key))
                    (<any>data["languageInfo"])[key] = this.languageInfo[key] ? this.languageInfo[key].toJSON() : <any>undefined;
            }
        }
        data["imageUrl"] = this.imageUrl;
        data["isVisible"] = this.isVisible;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["taxPercentage"] = this.taxPercentage;
        if (Array.isArray(this.menuItemIds)) {
            data["menuItemIds"] = [];
            for (let item of this.menuItemIds)
                data["menuItemIds"].push(item);
        }
        data["bundleId"] = this.bundleId;
        if (Array.isArray(this.schedules)) {
            data["schedules"] = [];
            for (let item of this.schedules)
                data["schedules"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuCategoryViewModel {
    id: string | undefined;
    languageInfo: { [key: string]: LanguageInfoViewModel; };
    imageUrl: string | undefined;
    isVisible: boolean;
    createdAt: Date;
    taxPercentage: number | undefined;
    menuItemIds: string[] | undefined;
    bundleId: string | undefined;
    schedules: VisibilityScheduleViewModel[] | undefined;
}

export class ScheduleViewModel implements IScheduleViewModel {
    id!: string | undefined;
    dayOfTheWeek!: number | undefined;
    startingHour!: number | undefined;
    startingMinute!: number | undefined;
    endingHour!: number | undefined;
    endingMinute!: number | undefined;
    notes!: string | undefined;
    expireAt!: Date | undefined;
    validFrom!: Date | undefined;

    constructor(data?: IScheduleViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dayOfTheWeek = _data["dayOfTheWeek"];
            this.startingHour = _data["startingHour"];
            this.startingMinute = _data["startingMinute"];
            this.endingHour = _data["endingHour"];
            this.endingMinute = _data["endingMinute"];
            this.notes = _data["notes"];
            this.expireAt = _data["expireAt"] ? new Date(_data["expireAt"].toString()) : <any>undefined;
            this.validFrom = _data["validFrom"] ? new Date(_data["validFrom"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ScheduleViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ScheduleViewModel>(data, _mappings, ScheduleViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dayOfTheWeek"] = this.dayOfTheWeek;
        data["startingHour"] = this.startingHour;
        data["startingMinute"] = this.startingMinute;
        data["endingHour"] = this.endingHour;
        data["endingMinute"] = this.endingMinute;
        data["notes"] = this.notes;
        data["expireAt"] = this.expireAt ? this.expireAt.toISOString() : <any>undefined;
        data["validFrom"] = this.validFrom ? this.validFrom.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScheduleViewModel {
    id: string | undefined;
    dayOfTheWeek: number | undefined;
    startingHour: number | undefined;
    startingMinute: number | undefined;
    endingHour: number | undefined;
    endingMinute: number | undefined;
    notes: string | undefined;
    expireAt: Date | undefined;
    validFrom: Date | undefined;
}

export class VisibilityScheduleViewModel extends ScheduleViewModel implements IVisibilityScheduleViewModel {
    isVisible!: boolean;

    constructor(data?: IVisibilityScheduleViewModel) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any, _mappings?: any): VisibilityScheduleViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<VisibilityScheduleViewModel>(data, _mappings, VisibilityScheduleViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        super.toJSON(data);
        return data;
    }
}

export interface IVisibilityScheduleViewModel extends IScheduleViewModel {
    isVisible: boolean;
}

export class MenuAttributeGroupViewModel implements IMenuAttributeGroupViewModel {
    id!: string | undefined;
    minSelections!: number;
    position!: number;
    maxSelections!: number | undefined;
    attributeItemIds!: string[];
    languageInfo!: { [key: string]: LanguageInfoViewModel; };
    defaultVariantAttributeItemId!: string | undefined;

    constructor(data?: IMenuAttributeGroupViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.attributeItemIds = [];
            this.languageInfo = {};
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.minSelections = _data["minSelections"];
            this.position = _data["position"];
            this.maxSelections = _data["maxSelections"];
            if (Array.isArray(_data["attributeItemIds"])) {
                this.attributeItemIds = [] as any;
                for (let item of _data["attributeItemIds"])
                    this.attributeItemIds!.push(item);
            }
            if (_data["languageInfo"]) {
                this.languageInfo = {} as any;
                for (let key in _data["languageInfo"]) {
                    if (_data["languageInfo"].hasOwnProperty(key))
                        (<any>this.languageInfo)![key] = _data["languageInfo"][key] ? LanguageInfoViewModel.fromJS(_data["languageInfo"][key], _mappings) : new LanguageInfoViewModel();
                }
            }
            this.defaultVariantAttributeItemId = _data["defaultVariantAttributeItemId"];
        }
    }

    static fromJS(data: any, _mappings?: any): MenuAttributeGroupViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuAttributeGroupViewModel>(data, _mappings, MenuAttributeGroupViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["minSelections"] = this.minSelections;
        data["position"] = this.position;
        data["maxSelections"] = this.maxSelections;
        if (Array.isArray(this.attributeItemIds)) {
            data["attributeItemIds"] = [];
            for (let item of this.attributeItemIds)
                data["attributeItemIds"].push(item);
        }
        if (this.languageInfo) {
            data["languageInfo"] = {};
            for (let key in this.languageInfo) {
                if (this.languageInfo.hasOwnProperty(key))
                    (<any>data["languageInfo"])[key] = this.languageInfo[key] ? this.languageInfo[key].toJSON() : <any>undefined;
            }
        }
        data["defaultVariantAttributeItemId"] = this.defaultVariantAttributeItemId;
        return data;
    }
}

export interface IMenuAttributeGroupViewModel {
    id: string | undefined;
    minSelections: number;
    position: number;
    maxSelections: number | undefined;
    attributeItemIds: string[];
    languageInfo: { [key: string]: LanguageInfoViewModel; };
    defaultVariantAttributeItemId: string | undefined;
}

export class MenuItemViewModel implements IMenuItemViewModel {
    id!: string | undefined;
    languageInfo!: { [key: string]: LanguageInfoViewModel; };
    medias!: MenuItemMediaViewModel[];
    inventoryProducts!: ItemInventoryProductViewModel[];
    isMenuRecommended!: boolean;
    price!: number;
    preparationTime!: number | undefined;
    createdAt!: Date;
    isVisible!: boolean;
    labels!: LabelTypeEnum[];
    recommended!: string[] | undefined;
    attributeGroupIds!: string[];
    variantAttributeGroupId!: string | undefined;
    taxPercentage!: number | undefined;
    kiloCalories!: number | undefined;
    notes!: string | undefined;
    recipe!: string | undefined;
    schedules!: VisibilityScheduleViewModel[] | undefined;

    constructor(data?: IMenuItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.languageInfo = {};
            this.medias = [];
            this.inventoryProducts = [];
            this.labels = [];
            this.attributeGroupIds = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["languageInfo"]) {
                this.languageInfo = {} as any;
                for (let key in _data["languageInfo"]) {
                    if (_data["languageInfo"].hasOwnProperty(key))
                        (<any>this.languageInfo)![key] = _data["languageInfo"][key] ? LanguageInfoViewModel.fromJS(_data["languageInfo"][key], _mappings) : new LanguageInfoViewModel();
                }
            }
            if (Array.isArray(_data["medias"])) {
                this.medias = [] as any;
                for (let item of _data["medias"])
                    this.medias!.push(MenuItemMediaViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["inventoryProducts"])) {
                this.inventoryProducts = [] as any;
                for (let item of _data["inventoryProducts"])
                    this.inventoryProducts!.push(ItemInventoryProductViewModel.fromJS(item, _mappings));
            }
            this.isMenuRecommended = _data["isMenuRecommended"];
            this.price = _data["price"];
            this.preparationTime = _data["preparationTime"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.isVisible = _data["isVisible"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["recommended"])) {
                this.recommended = [] as any;
                for (let item of _data["recommended"])
                    this.recommended!.push(item);
            }
            if (Array.isArray(_data["attributeGroupIds"])) {
                this.attributeGroupIds = [] as any;
                for (let item of _data["attributeGroupIds"])
                    this.attributeGroupIds!.push(item);
            }
            this.variantAttributeGroupId = _data["variantAttributeGroupId"];
            this.taxPercentage = _data["taxPercentage"];
            this.kiloCalories = _data["kiloCalories"];
            this.notes = _data["notes"];
            this.recipe = _data["recipe"];
            if (Array.isArray(_data["schedules"])) {
                this.schedules = [] as any;
                for (let item of _data["schedules"])
                    this.schedules!.push(VisibilityScheduleViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MenuItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuItemViewModel>(data, _mappings, MenuItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.languageInfo) {
            data["languageInfo"] = {};
            for (let key in this.languageInfo) {
                if (this.languageInfo.hasOwnProperty(key))
                    (<any>data["languageInfo"])[key] = this.languageInfo[key] ? this.languageInfo[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.medias)) {
            data["medias"] = [];
            for (let item of this.medias)
                data["medias"].push(item.toJSON());
        }
        if (Array.isArray(this.inventoryProducts)) {
            data["inventoryProducts"] = [];
            for (let item of this.inventoryProducts)
                data["inventoryProducts"].push(item.toJSON());
        }
        data["isMenuRecommended"] = this.isMenuRecommended;
        data["price"] = this.price;
        data["preparationTime"] = this.preparationTime;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.recommended)) {
            data["recommended"] = [];
            for (let item of this.recommended)
                data["recommended"].push(item);
        }
        if (Array.isArray(this.attributeGroupIds)) {
            data["attributeGroupIds"] = [];
            for (let item of this.attributeGroupIds)
                data["attributeGroupIds"].push(item);
        }
        data["variantAttributeGroupId"] = this.variantAttributeGroupId;
        data["taxPercentage"] = this.taxPercentage;
        data["kiloCalories"] = this.kiloCalories;
        data["notes"] = this.notes;
        data["recipe"] = this.recipe;
        if (Array.isArray(this.schedules)) {
            data["schedules"] = [];
            for (let item of this.schedules)
                data["schedules"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuItemViewModel {
    id: string | undefined;
    languageInfo: { [key: string]: LanguageInfoViewModel; };
    medias: MenuItemMediaViewModel[];
    inventoryProducts: ItemInventoryProductViewModel[];
    isMenuRecommended: boolean;
    price: number;
    preparationTime: number | undefined;
    createdAt: Date;
    isVisible: boolean;
    labels: LabelTypeEnum[];
    recommended: string[] | undefined;
    attributeGroupIds: string[];
    variantAttributeGroupId: string | undefined;
    taxPercentage: number | undefined;
    kiloCalories: number | undefined;
    notes: string | undefined;
    recipe: string | undefined;
    schedules: VisibilityScheduleViewModel[] | undefined;
}

export class MenuItemMediaViewModel implements IMenuItemMediaViewModel {
    id!: string | undefined;
    mediaUrl!: string | undefined;
    isVideo!: boolean;

    constructor(data?: IMenuItemMediaViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.mediaUrl = _data["mediaUrl"];
            this.isVideo = _data["isVideo"];
        }
    }

    static fromJS(data: any, _mappings?: any): MenuItemMediaViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuItemMediaViewModel>(data, _mappings, MenuItemMediaViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mediaUrl"] = this.mediaUrl;
        data["isVideo"] = this.isVideo;
        return data;
    }
}

export interface IMenuItemMediaViewModel {
    id: string | undefined;
    mediaUrl: string | undefined;
    isVideo: boolean;
}

export enum LabelTypeEnum {
    New = 1,
    Recommended = 2,
    Nuts = 3,
    Spicy = 4,
    Vegetarian = 5,
    Gluten = 6,
    RawMeat = 7,
    RawFish = 8,
    Seafood = 9,
    Shellfish = 10,
    Eggs = 11,
    Soy = 12,
    Wheat = 13,
    Peanuts = 14,
    Sesame = 15,
    Lactose = 16,
    Alcohol = 17,
    LowCal = 18,
    Vegan = 19,
    Mustard = 20,
    Sulphites = 21,
}

export class MenuAttributeItemViewModel implements IMenuAttributeItemViewModel {
    id!: string | undefined;
    price!: number;
    maxSelections!: number | undefined;
    languageInfo!: { [key: string]: LanguageInfoViewModel; };
    isVisible!: boolean;
    kiloCalories!: number | undefined;
    labels!: LabelTypeEnum[];
    inventoryProducts!: ItemInventoryProductViewModel[];
    taxPercentage!: number | undefined;

    constructor(data?: IMenuAttributeItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.languageInfo = {};
            this.labels = [];
            this.inventoryProducts = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.maxSelections = _data["maxSelections"];
            if (_data["languageInfo"]) {
                this.languageInfo = {} as any;
                for (let key in _data["languageInfo"]) {
                    if (_data["languageInfo"].hasOwnProperty(key))
                        (<any>this.languageInfo)![key] = _data["languageInfo"][key] ? LanguageInfoViewModel.fromJS(_data["languageInfo"][key], _mappings) : new LanguageInfoViewModel();
                }
            }
            this.isVisible = _data["isVisible"];
            this.kiloCalories = _data["kiloCalories"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["inventoryProducts"])) {
                this.inventoryProducts = [] as any;
                for (let item of _data["inventoryProducts"])
                    this.inventoryProducts!.push(ItemInventoryProductViewModel.fromJS(item, _mappings));
            }
            this.taxPercentage = _data["taxPercentage"];
        }
    }

    static fromJS(data: any, _mappings?: any): MenuAttributeItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuAttributeItemViewModel>(data, _mappings, MenuAttributeItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["maxSelections"] = this.maxSelections;
        if (this.languageInfo) {
            data["languageInfo"] = {};
            for (let key in this.languageInfo) {
                if (this.languageInfo.hasOwnProperty(key))
                    (<any>data["languageInfo"])[key] = this.languageInfo[key] ? this.languageInfo[key].toJSON() : <any>undefined;
            }
        }
        data["isVisible"] = this.isVisible;
        data["kiloCalories"] = this.kiloCalories;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.inventoryProducts)) {
            data["inventoryProducts"] = [];
            for (let item of this.inventoryProducts)
                data["inventoryProducts"].push(item.toJSON());
        }
        data["taxPercentage"] = this.taxPercentage;
        return data;
    }
}

export interface IMenuAttributeItemViewModel {
    id: string | undefined;
    price: number;
    maxSelections: number | undefined;
    languageInfo: { [key: string]: LanguageInfoViewModel; };
    isVisible: boolean;
    kiloCalories: number | undefined;
    labels: LabelTypeEnum[];
    inventoryProducts: ItemInventoryProductViewModel[];
    taxPercentage: number | undefined;
}

export class MenuBundleViewModel implements IMenuBundleViewModel {
    id!: string | undefined;
    price!: number;
    isVisible!: boolean;
    languageInfo!: { [key: string]: LanguageInfoViewModel; } | undefined;
    bundleCategories!: MenuBundleCategoryViewModel[] | undefined;

    constructor(data?: IMenuBundleViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.isVisible = _data["isVisible"];
            if (_data["languageInfo"]) {
                this.languageInfo = {} as any;
                for (let key in _data["languageInfo"]) {
                    if (_data["languageInfo"].hasOwnProperty(key))
                        (<any>this.languageInfo)![key] = _data["languageInfo"][key] ? LanguageInfoViewModel.fromJS(_data["languageInfo"][key], _mappings) : new LanguageInfoViewModel();
                }
            }
            if (Array.isArray(_data["bundleCategories"])) {
                this.bundleCategories = [] as any;
                for (let item of _data["bundleCategories"])
                    this.bundleCategories!.push(MenuBundleCategoryViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MenuBundleViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuBundleViewModel>(data, _mappings, MenuBundleViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["isVisible"] = this.isVisible;
        if (this.languageInfo) {
            data["languageInfo"] = {};
            for (let key in this.languageInfo) {
                if (this.languageInfo.hasOwnProperty(key))
                    (<any>data["languageInfo"])[key] = this.languageInfo[key] ? this.languageInfo[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.bundleCategories)) {
            data["bundleCategories"] = [];
            for (let item of this.bundleCategories)
                data["bundleCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuBundleViewModel {
    id: string | undefined;
    price: number;
    isVisible: boolean;
    languageInfo: { [key: string]: LanguageInfoViewModel; } | undefined;
    bundleCategories: MenuBundleCategoryViewModel[] | undefined;
}

export class MenuBundleCategoryViewModel implements IMenuBundleCategoryViewModel {
    id!: string | undefined;
    maxItems!: number;
    languageInfo!: { [key: string]: LanguageInfoViewModel; } | undefined;
    menuItems!: MenuBundleCategoryItemViewModel[] | undefined;

    constructor(data?: IMenuBundleCategoryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.maxItems = _data["maxItems"];
            if (_data["languageInfo"]) {
                this.languageInfo = {} as any;
                for (let key in _data["languageInfo"]) {
                    if (_data["languageInfo"].hasOwnProperty(key))
                        (<any>this.languageInfo)![key] = _data["languageInfo"][key] ? LanguageInfoViewModel.fromJS(_data["languageInfo"][key], _mappings) : new LanguageInfoViewModel();
                }
            }
            if (Array.isArray(_data["menuItems"])) {
                this.menuItems = [] as any;
                for (let item of _data["menuItems"])
                    this.menuItems!.push(MenuBundleCategoryItemViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): MenuBundleCategoryViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuBundleCategoryViewModel>(data, _mappings, MenuBundleCategoryViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maxItems"] = this.maxItems;
        if (this.languageInfo) {
            data["languageInfo"] = {};
            for (let key in this.languageInfo) {
                if (this.languageInfo.hasOwnProperty(key))
                    (<any>data["languageInfo"])[key] = this.languageInfo[key] ? this.languageInfo[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.menuItems)) {
            data["menuItems"] = [];
            for (let item of this.menuItems)
                data["menuItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMenuBundleCategoryViewModel {
    id: string | undefined;
    maxItems: number;
    languageInfo: { [key: string]: LanguageInfoViewModel; } | undefined;
    menuItems: MenuBundleCategoryItemViewModel[] | undefined;
}

export class MenuBundleCategoryItemViewModel implements IMenuBundleCategoryItemViewModel {
    id!: string | undefined;
    extraPrice!: number | undefined;

    constructor(data?: IMenuBundleCategoryItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.extraPrice = _data["extraPrice"];
        }
    }

    static fromJS(data: any, _mappings?: any): MenuBundleCategoryItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuBundleCategoryItemViewModel>(data, _mappings, MenuBundleCategoryItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["extraPrice"] = this.extraPrice;
        return data;
    }
}

export interface IMenuBundleCategoryItemViewModel {
    id: string | undefined;
    extraPrice: number | undefined;
}

export class PaginatedResultOfMenuListItemViewModel implements IPaginatedResultOfMenuListItemViewModel {
    items!: MenuListItemViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfMenuListItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MenuListItemViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfMenuListItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfMenuListItemViewModel>(data, _mappings, PaginatedResultOfMenuListItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfMenuListItemViewModel {
    items: MenuListItemViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class MenuListItemViewModel implements IMenuListItemViewModel {
    id!: string;
    languageInfo!: LanguageInfoViewModel;
    languages!: string[];
    isActive!: boolean;
    isFixedPrice!: boolean;
    imageUrl!: string;
    createdAt!: Date;
    updatedAt!: Date;
    categoriesCount!: number;
    menuItemsCount!: number;
    price!: number | undefined;

    constructor(data?: IMenuListItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.languageInfo = new LanguageInfoViewModel();
            this.languages = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.languageInfo = _data["languageInfo"] ? LanguageInfoViewModel.fromJS(_data["languageInfo"], _mappings) : new LanguageInfoViewModel();
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            this.isActive = _data["isActive"];
            this.isFixedPrice = _data["isFixedPrice"];
            this.imageUrl = _data["imageUrl"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.categoriesCount = _data["categoriesCount"];
            this.menuItemsCount = _data["menuItemsCount"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any, _mappings?: any): MenuListItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MenuListItemViewModel>(data, _mappings, MenuListItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["languageInfo"] = this.languageInfo ? this.languageInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        data["isActive"] = this.isActive;
        data["isFixedPrice"] = this.isFixedPrice;
        data["imageUrl"] = this.imageUrl;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["categoriesCount"] = this.categoriesCount;
        data["menuItemsCount"] = this.menuItemsCount;
        data["price"] = this.price;
        return data;
    }
}

export interface IMenuListItemViewModel {
    id: string;
    languageInfo: LanguageInfoViewModel;
    languages: string[];
    isActive: boolean;
    isFixedPrice: boolean;
    imageUrl: string;
    createdAt: Date;
    updatedAt: Date;
    categoriesCount: number;
    menuItemsCount: number;
    price: number | undefined;
}

export enum OrderStatusEnum {
    Created = 1,
    ProcessingPayment = 2,
    Sent = 3,
    Accepted = 4,
    Preparing = 5,
    Ready = 6,
    Packing = 7,
    Shipped = 8,
    Done = 9,
    Rejected = 10,
    Canceled = 11,
    WaitingCollectionAtStore = 12,
    WaitingDropOffAtCustomer = 13,
}

export class RefundRequest implements IRefundRequest {
    refundOrderItems!: string[] | undefined;
    refundOrderItemAttributes!: string[] | undefined;
    markAsInvisible!: boolean;

    constructor(data?: IRefundRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["refundOrderItems"])) {
                this.refundOrderItems = [] as any;
                for (let item of _data["refundOrderItems"])
                    this.refundOrderItems!.push(item);
            }
            if (Array.isArray(_data["refundOrderItemAttributes"])) {
                this.refundOrderItemAttributes = [] as any;
                for (let item of _data["refundOrderItemAttributes"])
                    this.refundOrderItemAttributes!.push(item);
            }
            this.markAsInvisible = _data["markAsInvisible"];
        }
    }

    static fromJS(data: any, _mappings?: any): RefundRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RefundRequest>(data, _mappings, RefundRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.refundOrderItems)) {
            data["refundOrderItems"] = [];
            for (let item of this.refundOrderItems)
                data["refundOrderItems"].push(item);
        }
        if (Array.isArray(this.refundOrderItemAttributes)) {
            data["refundOrderItemAttributes"] = [];
            for (let item of this.refundOrderItemAttributes)
                data["refundOrderItemAttributes"].push(item);
        }
        data["markAsInvisible"] = this.markAsInvisible;
        return data;
    }
}

export interface IRefundRequest {
    refundOrderItems: string[] | undefined;
    refundOrderItemAttributes: string[] | undefined;
    markAsInvisible: boolean;
}

export class UpdateOrderStatusRequest extends RefundRequest implements IUpdateOrderStatusRequest {
    status!: OrderStatusEnum;
    force!: boolean;

    constructor(data?: IUpdateOrderStatusRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.status = _data["status"];
            this.force = _data["force"];
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateOrderStatusRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateOrderStatusRequest>(data, _mappings, UpdateOrderStatusRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["force"] = this.force;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateOrderStatusRequest extends IRefundRequest {
    status: OrderStatusEnum;
    force: boolean;
}

export class PaginatedResultOfOrderListItemViewModel implements IPaginatedResultOfOrderListItemViewModel {
    items!: OrderListItemViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfOrderListItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderListItemViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfOrderListItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfOrderListItemViewModel>(data, _mappings, PaginatedResultOfOrderListItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfOrderListItemViewModel {
    items: OrderListItemViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class OrderListItemViewModel implements IOrderListItemViewModel {
    restaurantId!: string | undefined;
    id!: string | undefined;
    receiptId!: string | undefined;
    amount!: number;
    orderTypeId!: OrderTypeEnum;
    sentAt!: Date;
    orderNumber!: number;
    ordersAccountId!: string | undefined;
    itemsCount!: number;
    statusId!: OrderStatusEnum;
    tableId!: string | undefined;

    constructor(data?: IOrderListItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.restaurantId = _data["restaurantId"];
            this.id = _data["id"];
            this.receiptId = _data["receiptId"];
            this.amount = _data["amount"];
            this.orderTypeId = _data["orderTypeId"];
            this.sentAt = _data["sentAt"] ? new Date(_data["sentAt"].toString()) : <any>undefined;
            this.orderNumber = _data["orderNumber"];
            this.ordersAccountId = _data["ordersAccountId"];
            this.itemsCount = _data["itemsCount"];
            this.statusId = _data["statusId"];
            this.tableId = _data["tableId"];
        }
    }

    static fromJS(data: any, _mappings?: any): OrderListItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderListItemViewModel>(data, _mappings, OrderListItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["restaurantId"] = this.restaurantId;
        data["id"] = this.id;
        data["receiptId"] = this.receiptId;
        data["amount"] = this.amount;
        data["orderTypeId"] = this.orderTypeId;
        data["sentAt"] = this.sentAt ? this.sentAt.toISOString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        data["ordersAccountId"] = this.ordersAccountId;
        data["itemsCount"] = this.itemsCount;
        data["statusId"] = this.statusId;
        data["tableId"] = this.tableId;
        return data;
    }
}

export interface IOrderListItemViewModel {
    restaurantId: string | undefined;
    id: string | undefined;
    receiptId: string | undefined;
    amount: number;
    orderTypeId: OrderTypeEnum;
    sentAt: Date;
    orderNumber: number;
    ordersAccountId: string | undefined;
    itemsCount: number;
    statusId: OrderStatusEnum;
    tableId: string | undefined;
}

export enum OrderTypeEnum {
    Table = 1,
    TakeAway = 2,
    Delivery = 3,
    Cashier = 4,
    Unset = -1,
}

export class OrderSearchRequest extends BaseSearchRequest implements IOrderSearchRequest {
    id!: string | undefined;
    sessionId!: string | undefined;
    orderNumber!: number | undefined;
    orderTypeId!: OrderTypeEnum | undefined;
    dateFrom!: Date | undefined;
    dateTo!: Date | undefined;

    constructor(data?: IOrderSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.sessionId = _data["sessionId"];
            this.orderNumber = _data["orderNumber"];
            this.orderTypeId = _data["orderTypeId"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): OrderSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderSearchRequest>(data, _mappings, OrderSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sessionId"] = this.sessionId;
        data["orderNumber"] = this.orderNumber;
        data["orderTypeId"] = this.orderTypeId;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IOrderSearchRequest extends IBaseSearchRequest {
    id: string | undefined;
    sessionId: string | undefined;
    orderNumber: number | undefined;
    orderTypeId: OrderTypeEnum | undefined;
    dateFrom: Date | undefined;
    dateTo: Date | undefined;
}

export class OrderViewModel extends OrderListItemViewModel implements IOrderViewModel {
    items!: OrderItemViewModel[];
    table!: FullTableViewModel | undefined;
    address!: AddressViewModel | undefined;
    scheduledAt!: Date | undefined;
    notes!: string | undefined;
    receipt!: ReceiptViewModel | undefined;
    menuId!: string | undefined;
    priceModifierTypeId!: PriceModifierTypeEnum | undefined;
    priceModifierValue!: number | undefined;
    createdAt!: Date;

    constructor(data?: IOrderViewModel) {
        super(data);
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderItemViewModel.fromJS(item, _mappings));
            }
            this.table = _data["table"] ? FullTableViewModel.fromJS(_data["table"], _mappings) : <any>undefined;
            this.address = _data["address"] ? AddressViewModel.fromJS(_data["address"], _mappings) : <any>undefined;
            this.scheduledAt = _data["scheduledAt"] ? new Date(_data["scheduledAt"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.receipt = _data["receipt"] ? ReceiptViewModel.fromJS(_data["receipt"], _mappings) : <any>undefined;
            this.menuId = _data["menuId"];
            this.priceModifierTypeId = _data["priceModifierTypeId"];
            this.priceModifierValue = _data["priceModifierValue"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): OrderViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderViewModel>(data, _mappings, OrderViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["table"] = this.table ? this.table.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["scheduledAt"] = this.scheduledAt ? this.scheduledAt.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["receipt"] = this.receipt ? this.receipt.toJSON() : <any>undefined;
        data["menuId"] = this.menuId;
        data["priceModifierTypeId"] = this.priceModifierTypeId;
        data["priceModifierValue"] = this.priceModifierValue;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IOrderViewModel extends IOrderListItemViewModel {
    items: OrderItemViewModel[];
    table: FullTableViewModel | undefined;
    address: AddressViewModel | undefined;
    scheduledAt: Date | undefined;
    notes: string | undefined;
    receipt: ReceiptViewModel | undefined;
    menuId: string | undefined;
    priceModifierTypeId: PriceModifierTypeEnum | undefined;
    priceModifierValue: number | undefined;
    createdAt: Date;
}

export class OrderItemViewModel implements IOrderItemViewModel {
    id!: string | undefined;
    itemName!: string | undefined;
    menuItemId!: string | undefined;
    price!: number;
    count!: number;
    priceModifierTypeId!: PriceModifierTypeEnum | undefined;
    priceModifierValue!: number | undefined;
    notes!: string | undefined;
    isRefunded!: boolean;
    isRemoved!: boolean;
    attributeGroups!: OrderItemAttributeGroupViewModel[] | undefined;

    constructor(data?: IOrderItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemName = _data["itemName"];
            this.menuItemId = _data["menuItemId"];
            this.price = _data["price"];
            this.count = _data["count"];
            this.priceModifierTypeId = _data["priceModifierTypeId"];
            this.priceModifierValue = _data["priceModifierValue"];
            this.notes = _data["notes"];
            this.isRefunded = _data["isRefunded"];
            this.isRemoved = _data["isRemoved"];
            if (Array.isArray(_data["attributeGroups"])) {
                this.attributeGroups = [] as any;
                for (let item of _data["attributeGroups"])
                    this.attributeGroups!.push(OrderItemAttributeGroupViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): OrderItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderItemViewModel>(data, _mappings, OrderItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemName"] = this.itemName;
        data["menuItemId"] = this.menuItemId;
        data["price"] = this.price;
        data["count"] = this.count;
        data["priceModifierTypeId"] = this.priceModifierTypeId;
        data["priceModifierValue"] = this.priceModifierValue;
        data["notes"] = this.notes;
        data["isRefunded"] = this.isRefunded;
        data["isRemoved"] = this.isRemoved;
        if (Array.isArray(this.attributeGroups)) {
            data["attributeGroups"] = [];
            for (let item of this.attributeGroups)
                data["attributeGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderItemViewModel {
    id: string | undefined;
    itemName: string | undefined;
    menuItemId: string | undefined;
    price: number;
    count: number;
    priceModifierTypeId: PriceModifierTypeEnum | undefined;
    priceModifierValue: number | undefined;
    notes: string | undefined;
    isRefunded: boolean;
    isRemoved: boolean;
    attributeGroups: OrderItemAttributeGroupViewModel[] | undefined;
}

export enum PriceModifierTypeEnum {
    DISCOUNT_PERCENTAGE = 1,
    DISCOUNT_AMOUNT = 2,
    SURCHARGE_PERCENTAGE = 3,
    SURCHARGE_AMOUNT = 4,
}

export class OrderItemAttributeGroupViewModel implements IOrderItemAttributeGroupViewModel {
    id!: string | undefined;
    orderItemAttributes!: OrderItemAttributeViewModel[] | undefined;

    constructor(data?: IOrderItemAttributeGroupViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["orderItemAttributes"])) {
                this.orderItemAttributes = [] as any;
                for (let item of _data["orderItemAttributes"])
                    this.orderItemAttributes!.push(OrderItemAttributeViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): OrderItemAttributeGroupViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderItemAttributeGroupViewModel>(data, _mappings, OrderItemAttributeGroupViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.orderItemAttributes)) {
            data["orderItemAttributes"] = [];
            for (let item of this.orderItemAttributes)
                data["orderItemAttributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderItemAttributeGroupViewModel {
    id: string | undefined;
    orderItemAttributes: OrderItemAttributeViewModel[] | undefined;
}

export class OrderItemAttributeViewModel implements IOrderItemAttributeViewModel {
    id!: string | undefined;
    isRefunded!: boolean;
    menuAttributeItemId!: string | undefined;
    attributeName!: string | undefined;
    count!: number;
    price!: number;
    isVariant!: boolean;

    constructor(data?: IOrderItemAttributeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isRefunded = _data["isRefunded"];
            this.menuAttributeItemId = _data["menuAttributeItemId"];
            this.attributeName = _data["attributeName"];
            this.count = _data["count"];
            this.price = _data["price"];
            this.isVariant = _data["isVariant"];
        }
    }

    static fromJS(data: any, _mappings?: any): OrderItemAttributeViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderItemAttributeViewModel>(data, _mappings, OrderItemAttributeViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isRefunded"] = this.isRefunded;
        data["menuAttributeItemId"] = this.menuAttributeItemId;
        data["attributeName"] = this.attributeName;
        data["count"] = this.count;
        data["price"] = this.price;
        data["isVariant"] = this.isVariant;
        return data;
    }
}

export interface IOrderItemAttributeViewModel {
    id: string | undefined;
    isRefunded: boolean;
    menuAttributeItemId: string | undefined;
    attributeName: string | undefined;
    count: number;
    price: number;
    isVariant: boolean;
}

export class FullTableViewModel implements IFullTableViewModel {
    id!: string | undefined;
    number!: number;
    groupName!: string | undefined;
    groupId!: string | undefined;

    constructor(data?: IFullTableViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.groupName = _data["groupName"];
            this.groupId = _data["groupId"];
        }
    }

    static fromJS(data: any, _mappings?: any): FullTableViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<FullTableViewModel>(data, _mappings, FullTableViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["groupName"] = this.groupName;
        data["groupId"] = this.groupId;
        return data;
    }
}

export interface IFullTableViewModel {
    id: string | undefined;
    number: number;
    groupName: string | undefined;
    groupId: string | undefined;
}

export class ReceiptViewModel implements IReceiptViewModel {
    id!: string;
    email!: string;
    transactionStatusId!: TransactionStatusEnum;
    paymentProviderId!: PaymentProviderEnum;
    transactionTypeId!: TransactionTypeEnum;
    orderId!: string | undefined;
    ordersAccountId!: string | undefined;
    createdAt!: Date;
    amount!: number;
    vatAmount!: number;
    tipsAmount!: number;
    transactionId!: string | undefined;
    refundedAmount!: number;
    userId!: string | undefined;
    canBeEdited!: boolean;
    customerId!: string | undefined;
    customerName!: string | undefined;
    orderTypeId!: OrderTypeEnum | undefined;
    orderItems!: string[] | undefined;

    constructor(data?: IReceiptViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.transactionStatusId = _data["transactionStatusId"];
            this.paymentProviderId = _data["paymentProviderId"];
            this.transactionTypeId = _data["transactionTypeId"];
            this.orderId = _data["orderId"];
            this.ordersAccountId = _data["ordersAccountId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.vatAmount = _data["vatAmount"];
            this.tipsAmount = _data["tipsAmount"];
            this.transactionId = _data["transactionId"];
            this.refundedAmount = _data["refundedAmount"];
            this.userId = _data["userId"];
            this.canBeEdited = _data["canBeEdited"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.orderTypeId = _data["orderTypeId"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): ReceiptViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ReceiptViewModel>(data, _mappings, ReceiptViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["transactionStatusId"] = this.transactionStatusId;
        data["paymentProviderId"] = this.paymentProviderId;
        data["transactionTypeId"] = this.transactionTypeId;
        data["orderId"] = this.orderId;
        data["ordersAccountId"] = this.ordersAccountId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["vatAmount"] = this.vatAmount;
        data["tipsAmount"] = this.tipsAmount;
        data["transactionId"] = this.transactionId;
        data["refundedAmount"] = this.refundedAmount;
        data["userId"] = this.userId;
        data["canBeEdited"] = this.canBeEdited;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["orderTypeId"] = this.orderTypeId;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item);
        }
        return data;
    }
}

export interface IReceiptViewModel {
    id: string;
    email: string;
    transactionStatusId: TransactionStatusEnum;
    paymentProviderId: PaymentProviderEnum;
    transactionTypeId: TransactionTypeEnum;
    orderId: string | undefined;
    ordersAccountId: string | undefined;
    createdAt: Date;
    amount: number;
    vatAmount: number;
    tipsAmount: number;
    transactionId: string | undefined;
    refundedAmount: number;
    userId: string | undefined;
    canBeEdited: boolean;
    customerId: string | undefined;
    customerName: string | undefined;
    orderTypeId: OrderTypeEnum | undefined;
    orderItems: string[] | undefined;
}

export enum PaymentProviderEnum {
    Cash = 1,
    Stripe = 2,
    Wallet = 3,
    CoinGate = 4,
    RoomCharge = 5,
    PayComet = 6,
    Checkout = 7,
    PhysicalCard = 8,
    Bank = 9,
    CustomerAccount = 10,
}

export enum TransactionTypeEnum {
    DirectCharge = 1,
    FutureCharge = 2,
    Refund = 3,
    PartialRefund = 4,
    CaptureRefund = 5,
    NotSet = -1,
}

export class CreateOrderResponse implements ICreateOrderResponse {
    ordersAccount!: OrdersAccountViewModel | undefined;
    orderId!: string | undefined;

    constructor(data?: ICreateOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.ordersAccount = _data["ordersAccount"] ? OrdersAccountViewModel.fromJS(_data["ordersAccount"], _mappings) : <any>undefined;
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any, _mappings?: any): CreateOrderResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateOrderResponse>(data, _mappings, CreateOrderResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ordersAccount"] = this.ordersAccount ? this.ordersAccount.toJSON() : <any>undefined;
        data["orderId"] = this.orderId;
        return data;
    }
}

export interface ICreateOrderResponse {
    ordersAccount: OrdersAccountViewModel | undefined;
    orderId: string | undefined;
}

export class OrdersAccountViewModel implements IOrdersAccountViewModel {
    id!: string;
    sessions!: KeyValuePairOfStringAndString[] | undefined;
    hasMoneySplit!: boolean;
    receipts!: ReceiptViewModel[] | undefined;
    orders!: OrderViewModel[] | undefined;
    lastId!: string | undefined;
    total!: number;
    table!: FullTableViewModel | undefined;
    priceModifierTypeId!: PriceModifierTypeEnum | undefined;
    priceModifierValue!: number | undefined;

    constructor(data?: IOrdersAccountViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["sessions"])) {
                this.sessions = [] as any;
                for (let item of _data["sessions"])
                    this.sessions!.push(KeyValuePairOfStringAndString.fromJS(item, _mappings));
            }
            this.hasMoneySplit = _data["hasMoneySplit"];
            if (Array.isArray(_data["receipts"])) {
                this.receipts = [] as any;
                for (let item of _data["receipts"])
                    this.receipts!.push(ReceiptViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(OrderViewModel.fromJS(item, _mappings));
            }
            this.lastId = _data["lastId"];
            this.total = _data["total"];
            this.table = _data["table"] ? FullTableViewModel.fromJS(_data["table"], _mappings) : <any>undefined;
            this.priceModifierTypeId = _data["priceModifierTypeId"];
            this.priceModifierValue = _data["priceModifierValue"];
        }
    }

    static fromJS(data: any, _mappings?: any): OrdersAccountViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrdersAccountViewModel>(data, _mappings, OrdersAccountViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.sessions)) {
            data["sessions"] = [];
            for (let item of this.sessions)
                data["sessions"].push(item.toJSON());
        }
        data["hasMoneySplit"] = this.hasMoneySplit;
        if (Array.isArray(this.receipts)) {
            data["receipts"] = [];
            for (let item of this.receipts)
                data["receipts"].push(item.toJSON());
        }
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["lastId"] = this.lastId;
        data["total"] = this.total;
        data["table"] = this.table ? this.table.toJSON() : <any>undefined;
        data["priceModifierTypeId"] = this.priceModifierTypeId;
        data["priceModifierValue"] = this.priceModifierValue;
        return data;
    }
}

export interface IOrdersAccountViewModel {
    id: string;
    sessions: KeyValuePairOfStringAndString[] | undefined;
    hasMoneySplit: boolean;
    receipts: ReceiptViewModel[] | undefined;
    orders: OrderViewModel[] | undefined;
    lastId: string | undefined;
    total: number;
    table: FullTableViewModel | undefined;
    priceModifierTypeId: PriceModifierTypeEnum | undefined;
    priceModifierValue: number | undefined;
}

export class KeyValuePairOfStringAndString implements IKeyValuePairOfStringAndString {
    key!: string;
    value!: string;

    constructor(data?: IKeyValuePairOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any, _mappings?: any): KeyValuePairOfStringAndString | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<KeyValuePairOfStringAndString>(data, _mappings, KeyValuePairOfStringAndString);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValuePairOfStringAndString {
    key: string;
    value: string;
}

export class UpdatePriceModifierRequest implements IUpdatePriceModifierRequest {
    priceModifierTypeId!: PriceModifierTypeEnum | undefined;
    value!: number;

    constructor(data?: IUpdatePriceModifierRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.priceModifierTypeId = _data["priceModifierTypeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any, _mappings?: any): UpdatePriceModifierRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdatePriceModifierRequest>(data, _mappings, UpdatePriceModifierRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceModifierTypeId"] = this.priceModifierTypeId;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdatePriceModifierRequest {
    priceModifierTypeId: PriceModifierTypeEnum | undefined;
    value: number;
}

export class ManualTransactionResponse implements IManualTransactionResponse {
    receiptId!: string | undefined;
    ordersAccount!: OrdersAccountViewModel | undefined;
    amountLeft!: number;

    constructor(data?: IManualTransactionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.receiptId = _data["receiptId"];
            this.ordersAccount = _data["ordersAccount"] ? OrdersAccountViewModel.fromJS(_data["ordersAccount"], _mappings) : <any>undefined;
            this.amountLeft = _data["amountLeft"];
        }
    }

    static fromJS(data: any, _mappings?: any): ManualTransactionResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ManualTransactionResponse>(data, _mappings, ManualTransactionResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiptId"] = this.receiptId;
        data["ordersAccount"] = this.ordersAccount ? this.ordersAccount.toJSON() : <any>undefined;
        data["amountLeft"] = this.amountLeft;
        return data;
    }
}

export interface IManualTransactionResponse {
    receiptId: string | undefined;
    ordersAccount: OrdersAccountViewModel | undefined;
    amountLeft: number;
}

export class CreateManualTransactionRequest implements ICreateManualTransactionRequest {
    forSessionId!: string | undefined;
    amount!: number;
    cashAmount!: number | undefined;
    deviceId!: string | undefined;
    paymentProviderId!: PaymentProviderEnum;
    orderItems!: string[] | undefined;

    constructor(data?: ICreateManualTransactionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.forSessionId = _data["forSessionId"];
            this.amount = _data["amount"];
            this.cashAmount = _data["cashAmount"];
            this.deviceId = _data["deviceId"];
            this.paymentProviderId = _data["paymentProviderId"];
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CreateManualTransactionRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateManualTransactionRequest>(data, _mappings, CreateManualTransactionRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["forSessionId"] = this.forSessionId;
        data["amount"] = this.amount;
        data["cashAmount"] = this.cashAmount;
        data["deviceId"] = this.deviceId;
        data["paymentProviderId"] = this.paymentProviderId;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item);
        }
        return data;
    }
}

export interface ICreateManualTransactionRequest {
    forSessionId: string | undefined;
    amount: number;
    cashAmount: number | undefined;
    deviceId: string | undefined;
    paymentProviderId: PaymentProviderEnum;
    orderItems: string[] | undefined;
}

export class OrdersAccountSessionViewModel implements IOrdersAccountSessionViewModel {
    sessionId!: string | undefined;
    nickName!: string | undefined;
    isApproved!: boolean | undefined;
    isPending!: boolean;

    constructor(data?: IOrdersAccountSessionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.nickName = _data["nickName"];
            this.isApproved = _data["isApproved"];
            this.isPending = _data["isPending"];
        }
    }

    static fromJS(data: any, _mappings?: any): OrdersAccountSessionViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrdersAccountSessionViewModel>(data, _mappings, OrdersAccountSessionViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["nickName"] = this.nickName;
        data["isApproved"] = this.isApproved;
        data["isPending"] = this.isPending;
        return data;
    }
}

export interface IOrdersAccountSessionViewModel {
    sessionId: string | undefined;
    nickName: string | undefined;
    isApproved: boolean | undefined;
    isPending: boolean;
}

export class OrdersAccountTransactionViewModel implements IOrdersAccountTransactionViewModel {
    ordersAccountId!: string | undefined;
    transactionId!: string | undefined;
    receiptId!: string | undefined;
    userId!: string | undefined;
    isSuccess!: boolean;
    amount!: number;
    tipsAmount!: number;
    createdAt!: Date;
    orderItems!: string[] | undefined;
    transactionStatusId!: TransactionStatusEnum;
    paymentProviderId!: PaymentProviderEnum;

    constructor(data?: IOrdersAccountTransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.ordersAccountId = _data["ordersAccountId"];
            this.transactionId = _data["transactionId"];
            this.receiptId = _data["receiptId"];
            this.userId = _data["userId"];
            this.isSuccess = _data["isSuccess"];
            this.amount = _data["amount"];
            this.tipsAmount = _data["tipsAmount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(item);
            }
            this.transactionStatusId = _data["transactionStatusId"];
            this.paymentProviderId = _data["paymentProviderId"];
        }
    }

    static fromJS(data: any, _mappings?: any): OrdersAccountTransactionViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrdersAccountTransactionViewModel>(data, _mappings, OrdersAccountTransactionViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ordersAccountId"] = this.ordersAccountId;
        data["transactionId"] = this.transactionId;
        data["receiptId"] = this.receiptId;
        data["userId"] = this.userId;
        data["isSuccess"] = this.isSuccess;
        data["amount"] = this.amount;
        data["tipsAmount"] = this.tipsAmount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item);
        }
        data["transactionStatusId"] = this.transactionStatusId;
        data["paymentProviderId"] = this.paymentProviderId;
        return data;
    }
}

export interface IOrdersAccountTransactionViewModel {
    ordersAccountId: string | undefined;
    transactionId: string | undefined;
    receiptId: string | undefined;
    userId: string | undefined;
    isSuccess: boolean;
    amount: number;
    tipsAmount: number;
    createdAt: Date;
    orderItems: string[] | undefined;
    transactionStatusId: TransactionStatusEnum;
    paymentProviderId: PaymentProviderEnum;
}

export class PaginatedResultOfReceiptViewModel implements IPaginatedResultOfReceiptViewModel {
    items!: ReceiptViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfReceiptViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReceiptViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfReceiptViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfReceiptViewModel>(data, _mappings, PaginatedResultOfReceiptViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfReceiptViewModel {
    items: ReceiptViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class ReceiptSearchRequest extends BaseSearchRequest implements IReceiptSearchRequest {
    id!: string | undefined;
    paymentProviderId!: PaymentProviderEnum | undefined;
    amountFrom!: number | undefined;
    amountTo!: number | undefined;
    dateFrom!: Date | undefined;
    dateTo!: Date | undefined;

    constructor(data?: IReceiptSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.paymentProviderId = _data["paymentProviderId"];
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ReceiptSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ReceiptSearchRequest>(data, _mappings, ReceiptSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentProviderId"] = this.paymentProviderId;
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IReceiptSearchRequest extends IBaseSearchRequest {
    id: string | undefined;
    paymentProviderId: PaymentProviderEnum | undefined;
    amountFrom: number | undefined;
    amountTo: number | undefined;
    dateFrom: Date | undefined;
    dateTo: Date | undefined;
}

export class EndOfPeriodReportViewModel implements IEndOfPeriodReportViewModel {
    commissionAmount!: number;
    transactionProvidersAmounts!: { [key in keyof typeof PaymentProviderEnum]?: number; } | undefined;
    total!: number;
    tipsAmount!: number;
    refundedAmount!: number;
    attributes!: OrderMenuAttributeItemViewModel[] | undefined;
    items!: OrderMenuItemViewModel[] | undefined;

    constructor(data?: IEndOfPeriodReportViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.commissionAmount = _data["commissionAmount"];
            if (_data["transactionProvidersAmounts"]) {
                this.transactionProvidersAmounts = {} as any;
                for (let key in _data["transactionProvidersAmounts"]) {
                    if (_data["transactionProvidersAmounts"].hasOwnProperty(key))
                        (<any>this.transactionProvidersAmounts)![key] = _data["transactionProvidersAmounts"][key];
                }
            }
            this.total = _data["total"];
            this.tipsAmount = _data["tipsAmount"];
            this.refundedAmount = _data["refundedAmount"];
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(OrderMenuAttributeItemViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderMenuItemViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): EndOfPeriodReportViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<EndOfPeriodReportViewModel>(data, _mappings, EndOfPeriodReportViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commissionAmount"] = this.commissionAmount;
        if (this.transactionProvidersAmounts) {
            data["transactionProvidersAmounts"] = {};
            for (let key in this.transactionProvidersAmounts) {
                if (this.transactionProvidersAmounts.hasOwnProperty(key))
                    (<any>data["transactionProvidersAmounts"])[key] = (<any>this.transactionProvidersAmounts)[key];
            }
        }
        data["total"] = this.total;
        data["tipsAmount"] = this.tipsAmount;
        data["refundedAmount"] = this.refundedAmount;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEndOfPeriodReportViewModel {
    commissionAmount: number;
    transactionProvidersAmounts: { [key in keyof typeof PaymentProviderEnum]?: number; } | undefined;
    total: number;
    tipsAmount: number;
    refundedAmount: number;
    attributes: OrderMenuAttributeItemViewModel[] | undefined;
    items: OrderMenuItemViewModel[] | undefined;
}

export class OrderMenuAttributeItemViewModel implements IOrderMenuAttributeItemViewModel {
    menuAttributeItemId!: string | undefined;
    amount!: number;
    itemsCount!: number;

    constructor(data?: IOrderMenuAttributeItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.menuAttributeItemId = _data["menuAttributeItemId"];
            this.amount = _data["amount"];
            this.itemsCount = _data["itemsCount"];
        }
    }

    static fromJS(data: any, _mappings?: any): OrderMenuAttributeItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderMenuAttributeItemViewModel>(data, _mappings, OrderMenuAttributeItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuAttributeItemId"] = this.menuAttributeItemId;
        data["amount"] = this.amount;
        data["itemsCount"] = this.itemsCount;
        return data;
    }
}

export interface IOrderMenuAttributeItemViewModel {
    menuAttributeItemId: string | undefined;
    amount: number;
    itemsCount: number;
}

export class OrderMenuItemViewModel implements IOrderMenuItemViewModel {
    menuItemId!: string | undefined;
    itemName!: string | undefined;
    amount!: number;
    itemsCount!: number;
    attributes!: OrderMenuAttributeItemViewModel[] | undefined;

    constructor(data?: IOrderMenuItemViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.menuItemId = _data["menuItemId"];
            this.itemName = _data["itemName"];
            this.amount = _data["amount"];
            this.itemsCount = _data["itemsCount"];
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(OrderMenuAttributeItemViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): OrderMenuItemViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderMenuItemViewModel>(data, _mappings, OrderMenuItemViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuItemId"] = this.menuItemId;
        data["itemName"] = this.itemName;
        data["amount"] = this.amount;
        data["itemsCount"] = this.itemsCount;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderMenuItemViewModel {
    menuItemId: string | undefined;
    itemName: string | undefined;
    amount: number;
    itemsCount: number;
    attributes: OrderMenuAttributeItemViewModel[] | undefined;
}

export class StoreViewModel implements IStoreViewModel {
    displayName!: string;
    id!: string | undefined;
    slug!: string;
    logoUrl!: string;
    currencyCode!: string;
    defaultLangCode!: string;
    defaultMenuId!: string | undefined;
    isActive!: boolean | undefined;
    skipReadyOrderStatus!: boolean;
    orderChannels!: OrderChannelViewModel[] | undefined;
    isLiveMode!: boolean;
    timeZoneId!: string | undefined;
    disableRequireApprovalToJoinTable!: boolean;

    constructor(data?: IStoreViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.id = _data["id"];
            this.slug = _data["slug"];
            this.logoUrl = _data["logoUrl"];
            this.currencyCode = _data["currencyCode"];
            this.defaultLangCode = _data["defaultLangCode"];
            this.defaultMenuId = _data["defaultMenuId"];
            this.isActive = _data["isActive"];
            this.skipReadyOrderStatus = _data["skipReadyOrderStatus"];
            if (Array.isArray(_data["orderChannels"])) {
                this.orderChannels = [] as any;
                for (let item of _data["orderChannels"])
                    this.orderChannels!.push(OrderChannelViewModel.fromJS(item, _mappings));
            }
            this.isLiveMode = _data["isLiveMode"];
            this.timeZoneId = _data["timeZoneId"];
            this.disableRequireApprovalToJoinTable = _data["disableRequireApprovalToJoinTable"];
        }
    }

    static fromJS(data: any, _mappings?: any): StoreViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<StoreViewModel>(data, _mappings, StoreViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["id"] = this.id;
        data["slug"] = this.slug;
        data["logoUrl"] = this.logoUrl;
        data["currencyCode"] = this.currencyCode;
        data["defaultLangCode"] = this.defaultLangCode;
        data["defaultMenuId"] = this.defaultMenuId;
        data["isActive"] = this.isActive;
        data["skipReadyOrderStatus"] = this.skipReadyOrderStatus;
        if (Array.isArray(this.orderChannels)) {
            data["orderChannels"] = [];
            for (let item of this.orderChannels)
                data["orderChannels"].push(item.toJSON());
        }
        data["isLiveMode"] = this.isLiveMode;
        data["timeZoneId"] = this.timeZoneId;
        data["disableRequireApprovalToJoinTable"] = this.disableRequireApprovalToJoinTable;
        return data;
    }
}

export interface IStoreViewModel {
    displayName: string;
    id: string | undefined;
    slug: string;
    logoUrl: string;
    currencyCode: string;
    defaultLangCode: string;
    defaultMenuId: string | undefined;
    isActive: boolean | undefined;
    skipReadyOrderStatus: boolean;
    orderChannels: OrderChannelViewModel[] | undefined;
    isLiveMode: boolean;
    timeZoneId: string | undefined;
    disableRequireApprovalToJoinTable: boolean;
}

export class StoreFullViewModel extends StoreViewModel implements IStoreFullViewModel {
    paymentProviders!: PaymentProviderViewModel[] | undefined;
    percentageFee!: number | undefined;
    company!: CompanyViewModel | undefined;
    address!: AddressViewModel | undefined;
    phoneNumber!: string | undefined;
    description!: string | undefined;
    emailAddress!: string | undefined;
    menuImageUrl!: string | undefined;
    welcomeMessage!: string | undefined;
    receiptMessage!: string | undefined;
    extraNotes!: string | undefined;
    hasPaymentBeforeOrder!: boolean;
    hasPaylater!: boolean;
    displayServiceButton!: boolean;
    socialShareDiscountPercentage!: number | undefined;
    tipsEnabled!: boolean;
    allowTableChange!: boolean;
    externalScripts!: ExternalScriptViewModel[] | undefined;
    connectedUsers!: string[];
    deliveryAreas!: StoreDeliveryAreaViewModel[] | undefined;
    closingSchedules!: ScheduleViewModel[] | undefined;
    openingSchedules!: ScheduleViewModel[] | undefined;
    takeAwaySchedules!: ScheduleViewModel[] | undefined;
    deliverySchedules!: ScheduleViewModel[] | undefined;
    externalLinks!: ExternalLinkViewModel[] | undefined;
    activeFeatures!: StorePlatformFeatureViewModel[] | undefined;

    constructor(data?: IStoreFullViewModel) {
        super(data);
        if (!data) {
            this.connectedUsers = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["paymentProviders"])) {
                this.paymentProviders = [] as any;
                for (let item of _data["paymentProviders"])
                    this.paymentProviders!.push(PaymentProviderViewModel.fromJS(item, _mappings));
            }
            this.percentageFee = _data["percentageFee"];
            this.company = _data["company"] ? CompanyViewModel.fromJS(_data["company"], _mappings) : <any>undefined;
            this.address = _data["address"] ? AddressViewModel.fromJS(_data["address"], _mappings) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.description = _data["description"];
            this.emailAddress = _data["emailAddress"];
            this.menuImageUrl = _data["menuImageUrl"];
            this.welcomeMessage = _data["welcomeMessage"];
            this.receiptMessage = _data["receiptMessage"];
            this.extraNotes = _data["extraNotes"];
            this.hasPaymentBeforeOrder = _data["hasPaymentBeforeOrder"];
            this.hasPaylater = _data["hasPaylater"];
            this.displayServiceButton = _data["displayServiceButton"];
            this.socialShareDiscountPercentage = _data["socialShareDiscountPercentage"];
            this.tipsEnabled = _data["tipsEnabled"];
            this.allowTableChange = _data["allowTableChange"];
            if (Array.isArray(_data["externalScripts"])) {
                this.externalScripts = [] as any;
                for (let item of _data["externalScripts"])
                    this.externalScripts!.push(ExternalScriptViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["connectedUsers"])) {
                this.connectedUsers = [] as any;
                for (let item of _data["connectedUsers"])
                    this.connectedUsers!.push(item);
            }
            if (Array.isArray(_data["deliveryAreas"])) {
                this.deliveryAreas = [] as any;
                for (let item of _data["deliveryAreas"])
                    this.deliveryAreas!.push(StoreDeliveryAreaViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["closingSchedules"])) {
                this.closingSchedules = [] as any;
                for (let item of _data["closingSchedules"])
                    this.closingSchedules!.push(ScheduleViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["openingSchedules"])) {
                this.openingSchedules = [] as any;
                for (let item of _data["openingSchedules"])
                    this.openingSchedules!.push(ScheduleViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["takeAwaySchedules"])) {
                this.takeAwaySchedules = [] as any;
                for (let item of _data["takeAwaySchedules"])
                    this.takeAwaySchedules!.push(ScheduleViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["deliverySchedules"])) {
                this.deliverySchedules = [] as any;
                for (let item of _data["deliverySchedules"])
                    this.deliverySchedules!.push(ScheduleViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["externalLinks"])) {
                this.externalLinks = [] as any;
                for (let item of _data["externalLinks"])
                    this.externalLinks!.push(ExternalLinkViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["activeFeatures"])) {
                this.activeFeatures = [] as any;
                for (let item of _data["activeFeatures"])
                    this.activeFeatures!.push(StorePlatformFeatureViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): StoreFullViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<StoreFullViewModel>(data, _mappings, StoreFullViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paymentProviders)) {
            data["paymentProviders"] = [];
            for (let item of this.paymentProviders)
                data["paymentProviders"].push(item.toJSON());
        }
        data["percentageFee"] = this.percentageFee;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["description"] = this.description;
        data["emailAddress"] = this.emailAddress;
        data["menuImageUrl"] = this.menuImageUrl;
        data["welcomeMessage"] = this.welcomeMessage;
        data["receiptMessage"] = this.receiptMessage;
        data["extraNotes"] = this.extraNotes;
        data["hasPaymentBeforeOrder"] = this.hasPaymentBeforeOrder;
        data["hasPaylater"] = this.hasPaylater;
        data["displayServiceButton"] = this.displayServiceButton;
        data["socialShareDiscountPercentage"] = this.socialShareDiscountPercentage;
        data["tipsEnabled"] = this.tipsEnabled;
        data["allowTableChange"] = this.allowTableChange;
        if (Array.isArray(this.externalScripts)) {
            data["externalScripts"] = [];
            for (let item of this.externalScripts)
                data["externalScripts"].push(item.toJSON());
        }
        if (Array.isArray(this.connectedUsers)) {
            data["connectedUsers"] = [];
            for (let item of this.connectedUsers)
                data["connectedUsers"].push(item);
        }
        if (Array.isArray(this.deliveryAreas)) {
            data["deliveryAreas"] = [];
            for (let item of this.deliveryAreas)
                data["deliveryAreas"].push(item.toJSON());
        }
        if (Array.isArray(this.closingSchedules)) {
            data["closingSchedules"] = [];
            for (let item of this.closingSchedules)
                data["closingSchedules"].push(item.toJSON());
        }
        if (Array.isArray(this.openingSchedules)) {
            data["openingSchedules"] = [];
            for (let item of this.openingSchedules)
                data["openingSchedules"].push(item.toJSON());
        }
        if (Array.isArray(this.takeAwaySchedules)) {
            data["takeAwaySchedules"] = [];
            for (let item of this.takeAwaySchedules)
                data["takeAwaySchedules"].push(item.toJSON());
        }
        if (Array.isArray(this.deliverySchedules)) {
            data["deliverySchedules"] = [];
            for (let item of this.deliverySchedules)
                data["deliverySchedules"].push(item.toJSON());
        }
        if (Array.isArray(this.externalLinks)) {
            data["externalLinks"] = [];
            for (let item of this.externalLinks)
                data["externalLinks"].push(item.toJSON());
        }
        if (Array.isArray(this.activeFeatures)) {
            data["activeFeatures"] = [];
            for (let item of this.activeFeatures)
                data["activeFeatures"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IStoreFullViewModel extends IStoreViewModel {
    paymentProviders: PaymentProviderViewModel[] | undefined;
    percentageFee: number | undefined;
    company: CompanyViewModel | undefined;
    address: AddressViewModel | undefined;
    phoneNumber: string | undefined;
    description: string | undefined;
    emailAddress: string | undefined;
    menuImageUrl: string | undefined;
    welcomeMessage: string | undefined;
    receiptMessage: string | undefined;
    extraNotes: string | undefined;
    hasPaymentBeforeOrder: boolean;
    hasPaylater: boolean;
    displayServiceButton: boolean;
    socialShareDiscountPercentage: number | undefined;
    tipsEnabled: boolean;
    allowTableChange: boolean;
    externalScripts: ExternalScriptViewModel[] | undefined;
    connectedUsers: string[];
    deliveryAreas: StoreDeliveryAreaViewModel[] | undefined;
    closingSchedules: ScheduleViewModel[] | undefined;
    openingSchedules: ScheduleViewModel[] | undefined;
    takeAwaySchedules: ScheduleViewModel[] | undefined;
    deliverySchedules: ScheduleViewModel[] | undefined;
    externalLinks: ExternalLinkViewModel[] | undefined;
    activeFeatures: StorePlatformFeatureViewModel[] | undefined;
}

export class PaymentProviderViewModel implements IPaymentProviderViewModel {
    paymentProviderId!: PaymentProviderEnum;
    accountId!: string | undefined;
    isActive!: boolean;
    extraSettingsJson!: string | undefined;
    fixedFee!: number | undefined;
    percentageFee!: number | undefined;
    minAmount!: number | undefined;
    isEnabled!: boolean | undefined;
    isLiveMode!: boolean;

    constructor(data?: IPaymentProviderViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.paymentProviderId = _data["paymentProviderId"];
            this.accountId = _data["accountId"];
            this.isActive = _data["isActive"];
            this.extraSettingsJson = _data["extraSettingsJson"];
            this.fixedFee = _data["fixedFee"];
            this.percentageFee = _data["percentageFee"];
            this.minAmount = _data["minAmount"];
            this.isEnabled = _data["isEnabled"];
            this.isLiveMode = _data["isLiveMode"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaymentProviderViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaymentProviderViewModel>(data, _mappings, PaymentProviderViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentProviderId"] = this.paymentProviderId;
        data["accountId"] = this.accountId;
        data["isActive"] = this.isActive;
        data["extraSettingsJson"] = this.extraSettingsJson;
        data["fixedFee"] = this.fixedFee;
        data["percentageFee"] = this.percentageFee;
        data["minAmount"] = this.minAmount;
        data["isEnabled"] = this.isEnabled;
        data["isLiveMode"] = this.isLiveMode;
        return data;
    }
}

export interface IPaymentProviderViewModel {
    paymentProviderId: PaymentProviderEnum;
    accountId: string | undefined;
    isActive: boolean;
    extraSettingsJson: string | undefined;
    fixedFee: number | undefined;
    percentageFee: number | undefined;
    minAmount: number | undefined;
    isEnabled: boolean | undefined;
    isLiveMode: boolean;
}

export class ExternalScriptViewModel implements IExternalScriptViewModel {
    id!: string | undefined;
    externalScriptTypeId!: ExternalScriptTypeEnum;
    identifier!: string | undefined;
    isActive!: boolean;

    constructor(data?: IExternalScriptViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalScriptTypeId = _data["externalScriptTypeId"];
            this.identifier = _data["identifier"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any, _mappings?: any): ExternalScriptViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExternalScriptViewModel>(data, _mappings, ExternalScriptViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalScriptTypeId"] = this.externalScriptTypeId;
        data["identifier"] = this.identifier;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IExternalScriptViewModel {
    id: string | undefined;
    externalScriptTypeId: ExternalScriptTypeEnum;
    identifier: string | undefined;
    isActive: boolean;
}

export enum ExternalScriptTypeEnum {
    GoogleAnalytics = 1,
    FacebookPixel = 2,
}

export class StoreDeliveryAreaViewModel implements IStoreDeliveryAreaViewModel {
    jsonCoordinates!: ValueTupleOfIntegerAndInteger[] | undefined;
    name!: string | undefined;
    estimatedMinutes!: number | undefined;
    deliveryFees!: number;
    minOrderAmount!: number;
    isCircleArea!: boolean;

    constructor(data?: IStoreDeliveryAreaViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["jsonCoordinates"])) {
                this.jsonCoordinates = [] as any;
                for (let item of _data["jsonCoordinates"])
                    this.jsonCoordinates!.push(ValueTupleOfIntegerAndInteger.fromJS(item, _mappings));
            }
            this.name = _data["name"];
            this.estimatedMinutes = _data["estimatedMinutes"];
            this.deliveryFees = _data["deliveryFees"];
            this.minOrderAmount = _data["minOrderAmount"];
            this.isCircleArea = _data["isCircleArea"];
        }
    }

    static fromJS(data: any, _mappings?: any): StoreDeliveryAreaViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<StoreDeliveryAreaViewModel>(data, _mappings, StoreDeliveryAreaViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.jsonCoordinates)) {
            data["jsonCoordinates"] = [];
            for (let item of this.jsonCoordinates)
                data["jsonCoordinates"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["estimatedMinutes"] = this.estimatedMinutes;
        data["deliveryFees"] = this.deliveryFees;
        data["minOrderAmount"] = this.minOrderAmount;
        data["isCircleArea"] = this.isCircleArea;
        return data;
    }
}

export interface IStoreDeliveryAreaViewModel {
    jsonCoordinates: ValueTupleOfIntegerAndInteger[] | undefined;
    name: string | undefined;
    estimatedMinutes: number | undefined;
    deliveryFees: number;
    minOrderAmount: number;
    isCircleArea: boolean;
}

export class ValueTupleOfIntegerAndInteger implements IValueTupleOfIntegerAndInteger {
    item1!: number;
    item2!: number;

    constructor(data?: IValueTupleOfIntegerAndInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any, _mappings?: any): ValueTupleOfIntegerAndInteger | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ValueTupleOfIntegerAndInteger>(data, _mappings, ValueTupleOfIntegerAndInteger);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data;
    }
}

export interface IValueTupleOfIntegerAndInteger {
    item1: number;
    item2: number;
}

export class ExternalLinkViewModel implements IExternalLinkViewModel {
    id!: string | undefined;
    value!: string | undefined;
    isVisible!: boolean;
    externalLinkTypeId!: ExternalLinkTypeEnum;

    constructor(data?: IExternalLinkViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.isVisible = _data["isVisible"];
            this.externalLinkTypeId = _data["externalLinkTypeId"];
        }
    }

    static fromJS(data: any, _mappings?: any): ExternalLinkViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ExternalLinkViewModel>(data, _mappings, ExternalLinkViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["isVisible"] = this.isVisible;
        data["externalLinkTypeId"] = this.externalLinkTypeId;
        return data;
    }
}

export interface IExternalLinkViewModel {
    id: string | undefined;
    value: string | undefined;
    isVisible: boolean;
    externalLinkTypeId: ExternalLinkTypeEnum;
}

export enum ExternalLinkTypeEnum {
    Website = 1,
    Facebook = 2,
    Instagram = 3,
    TripAdvisor = 4,
    Google = 5,
    Twitter = 6,
    TikTok = 7,
    Youtube = 8,
}

export class OrderChannelViewModel implements IOrderChannelViewModel {
    orderTypeId!: OrderTypeEnum;
    isOpen!: boolean;
    isEnabled!: boolean;
    additionalPercentageFee!: number | undefined;
    additionalFixedFee!: number | undefined;

    constructor(data?: IOrderChannelViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.orderTypeId = _data["orderTypeId"];
            this.isOpen = _data["isOpen"];
            this.isEnabled = _data["isEnabled"];
            this.additionalPercentageFee = _data["additionalPercentageFee"];
            this.additionalFixedFee = _data["additionalFixedFee"];
        }
    }

    static fromJS(data: any, _mappings?: any): OrderChannelViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OrderChannelViewModel>(data, _mappings, OrderChannelViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderTypeId"] = this.orderTypeId;
        data["isOpen"] = this.isOpen;
        data["isEnabled"] = this.isEnabled;
        data["additionalPercentageFee"] = this.additionalPercentageFee;
        data["additionalFixedFee"] = this.additionalFixedFee;
        return data;
    }
}

export interface IOrderChannelViewModel {
    orderTypeId: OrderTypeEnum;
    isOpen: boolean;
    isEnabled: boolean;
    additionalPercentageFee: number | undefined;
    additionalFixedFee: number | undefined;
}

export class PaginatedResultOfStoreViewModel implements IPaginatedResultOfStoreViewModel {
    items!: StoreViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfStoreViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfStoreViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfStoreViewModel>(data, _mappings, PaginatedResultOfStoreViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfStoreViewModel {
    items: StoreViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class RestaurantSearchRequest extends BaseSearchRequest implements IRestaurantSearchRequest {
    displayName!: string | undefined;
    slug!: string | undefined;
    countryId!: number | undefined;
    isActive!: boolean | undefined;

    constructor(data?: IRestaurantSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.displayName = _data["displayName"];
            this.slug = _data["slug"];
            this.countryId = _data["countryId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any, _mappings?: any): RestaurantSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RestaurantSearchRequest>(data, _mappings, RestaurantSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["slug"] = this.slug;
        data["countryId"] = this.countryId;
        data["isActive"] = this.isActive;
        super.toJSON(data);
        return data;
    }
}

export interface IRestaurantSearchRequest extends IBaseSearchRequest {
    displayName: string | undefined;
    slug: string | undefined;
    countryId: number | undefined;
    isActive: boolean | undefined;
}

export class TableGroupViewModel implements ITableGroupViewModel {
    id!: string | undefined;
    name!: string;
    isActive!: boolean;
    tables!: TableViewModel[];
    floorSetupJson!: string | undefined;

    constructor(data?: ITableGroupViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tables = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["tables"])) {
                this.tables = [] as any;
                for (let item of _data["tables"])
                    this.tables!.push(TableViewModel.fromJS(item, _mappings));
            }
            this.floorSetupJson = _data["floorSetupJson"];
        }
    }

    static fromJS(data: any, _mappings?: any): TableGroupViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TableGroupViewModel>(data, _mappings, TableGroupViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.tables)) {
            data["tables"] = [];
            for (let item of this.tables)
                data["tables"].push(item.toJSON());
        }
        data["floorSetupJson"] = this.floorSetupJson;
        return data;
    }
}

export interface ITableGroupViewModel {
    id: string | undefined;
    name: string;
    isActive: boolean;
    tables: TableViewModel[];
    floorSetupJson: string | undefined;
}

export class TableViewModel implements ITableViewModel {
    id!: string | undefined;
    seats!: number | undefined;
    number!: number;
    name!: string | undefined;
    positionX!: number | undefined;
    positionY!: number | undefined;
    height!: number | undefined;
    width!: number | undefined;
    colorCode!: string | undefined;
    rotation!: number | undefined;
    isActive!: boolean;

    constructor(data?: ITableViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seats = _data["seats"];
            this.number = _data["number"];
            this.name = _data["name"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.colorCode = _data["colorCode"];
            this.rotation = _data["rotation"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any, _mappings?: any): TableViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TableViewModel>(data, _mappings, TableViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seats"] = this.seats;
        data["number"] = this.number;
        data["name"] = this.name;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        data["height"] = this.height;
        data["width"] = this.width;
        data["colorCode"] = this.colorCode;
        data["rotation"] = this.rotation;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ITableViewModel {
    id: string | undefined;
    seats: number | undefined;
    number: number;
    name: string | undefined;
    positionX: number | undefined;
    positionY: number | undefined;
    height: number | undefined;
    width: number | undefined;
    colorCode: string | undefined;
    rotation: number | undefined;
    isActive: boolean;
}

export class DownloadTablesFileOptions implements IDownloadTablesFileOptions {
    format!: TablePrintFormat;
    externalLinkIds!: string[] | undefined;
    languages!: string[] | undefined;
    useDarkBackground!: boolean;

    constructor(data?: IDownloadTablesFileOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.format = _data["format"];
            if (Array.isArray(_data["externalLinkIds"])) {
                this.externalLinkIds = [] as any;
                for (let item of _data["externalLinkIds"])
                    this.externalLinkIds!.push(item);
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            this.useDarkBackground = _data["useDarkBackground"];
        }
    }

    static fromJS(data: any, _mappings?: any): DownloadTablesFileOptions | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DownloadTablesFileOptions>(data, _mappings, DownloadTablesFileOptions);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        if (Array.isArray(this.externalLinkIds)) {
            data["externalLinkIds"] = [];
            for (let item of this.externalLinkIds)
                data["externalLinkIds"].push(item);
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        data["useDarkBackground"] = this.useDarkBackground;
        return data;
    }
}

export interface IDownloadTablesFileOptions {
    format: TablePrintFormat;
    externalLinkIds: string[] | undefined;
    languages: string[] | undefined;
    useDarkBackground: boolean;
}

export enum TablePrintFormat {
    A6 = 0,
    A7 = 1,
    Square = 2,
    A6Fold = 3,
}

export class PaginatedResultOfNotificationViewModel implements IPaginatedResultOfNotificationViewModel {
    items!: NotificationViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfNotificationViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NotificationViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfNotificationViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfNotificationViewModel>(data, _mappings, PaginatedResultOfNotificationViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfNotificationViewModel {
    items: NotificationViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class NotificationViewModel implements INotificationViewModel {
    id!: string | undefined;
    notificationTypeId!: PlatformNotificationTypeEnum;
    data!: string | undefined;
    createdAt!: Date;
    readAt!: Date | undefined;

    constructor(data?: INotificationViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.notificationTypeId = _data["notificationTypeId"];
            this.data = _data["data"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.readAt = _data["readAt"] ? new Date(_data["readAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): NotificationViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<NotificationViewModel>(data, _mappings, NotificationViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["notificationTypeId"] = this.notificationTypeId;
        data["data"] = this.data;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["readAt"] = this.readAt ? this.readAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface INotificationViewModel {
    id: string | undefined;
    notificationTypeId: PlatformNotificationTypeEnum;
    data: string | undefined;
    createdAt: Date;
    readAt: Date | undefined;
}

export enum PlatformNotificationTypeEnum {
    WAITER_REQUESTED = 1,
    CHECKOUT_REQUESTED = 2,
    BOOKING_REQUESTED = 3,
    TABLE_JOIN_REQUESTED = 4,
    NEW_INVOICE = 5,
}

export class PaginatedResultOfTransactionViewModel implements IPaginatedResultOfTransactionViewModel {
    items!: TransactionViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfTransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransactionViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfTransactionViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfTransactionViewModel>(data, _mappings, PaginatedResultOfTransactionViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfTransactionViewModel {
    items: TransactionViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class TransactionViewModel implements ITransactionViewModel {
    id!: string | undefined;
    restaurantId!: string | undefined;
    externalTransactionId!: string | undefined;
    receiverAccountId!: string | undefined;
    transactionTypeId!: TransactionTypeEnum;
    referenceId!: string | undefined;
    referenceTypeId!: ReferenceTypeEnum;
    transactionStatusId!: TransactionStatusEnum;
    parentTransactionId!: string | undefined;
    sessionId!: string | undefined;
    platformUserId!: string | undefined;
    amount!: number;
    feesAmount!: number;
    currencyCode!: string | undefined;
    paymentProviderId!: PaymentProviderEnum;
    unsettled!: boolean;
    walletId!: string | undefined;
    additionalInfoJson!: string | undefined;
    createdAt!: Date;

    constructor(data?: ITransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.restaurantId = _data["restaurantId"];
            this.externalTransactionId = _data["externalTransactionId"];
            this.receiverAccountId = _data["receiverAccountId"];
            this.transactionTypeId = _data["transactionTypeId"];
            this.referenceId = _data["referenceId"];
            this.referenceTypeId = _data["referenceTypeId"];
            this.transactionStatusId = _data["transactionStatusId"];
            this.parentTransactionId = _data["parentTransactionId"];
            this.sessionId = _data["sessionId"];
            this.platformUserId = _data["platformUserId"];
            this.amount = _data["amount"];
            this.feesAmount = _data["feesAmount"];
            this.currencyCode = _data["currencyCode"];
            this.paymentProviderId = _data["paymentProviderId"];
            this.unsettled = _data["unsettled"];
            this.walletId = _data["walletId"];
            this.additionalInfoJson = _data["additionalInfoJson"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): TransactionViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TransactionViewModel>(data, _mappings, TransactionViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["restaurantId"] = this.restaurantId;
        data["externalTransactionId"] = this.externalTransactionId;
        data["receiverAccountId"] = this.receiverAccountId;
        data["transactionTypeId"] = this.transactionTypeId;
        data["referenceId"] = this.referenceId;
        data["referenceTypeId"] = this.referenceTypeId;
        data["transactionStatusId"] = this.transactionStatusId;
        data["parentTransactionId"] = this.parentTransactionId;
        data["sessionId"] = this.sessionId;
        data["platformUserId"] = this.platformUserId;
        data["amount"] = this.amount;
        data["feesAmount"] = this.feesAmount;
        data["currencyCode"] = this.currencyCode;
        data["paymentProviderId"] = this.paymentProviderId;
        data["unsettled"] = this.unsettled;
        data["walletId"] = this.walletId;
        data["additionalInfoJson"] = this.additionalInfoJson;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITransactionViewModel {
    id: string | undefined;
    restaurantId: string | undefined;
    externalTransactionId: string | undefined;
    receiverAccountId: string | undefined;
    transactionTypeId: TransactionTypeEnum;
    referenceId: string | undefined;
    referenceTypeId: ReferenceTypeEnum;
    transactionStatusId: TransactionStatusEnum;
    parentTransactionId: string | undefined;
    sessionId: string | undefined;
    platformUserId: string | undefined;
    amount: number;
    feesAmount: number;
    currencyCode: string | undefined;
    paymentProviderId: PaymentProviderEnum;
    unsettled: boolean;
    walletId: string | undefined;
    additionalInfoJson: string | undefined;
    createdAt: Date;
}

export enum ReferenceTypeEnum {
    ORDER_CHECKOUT = 1,
    ORDERS_ACCOUNT_CHECKOUT = 2,
}

export class TransactionSearchRequest extends BaseSearchRequest implements ITransactionSearchRequest {
    id!: string | undefined;
    restaurantId!: string | undefined;
    sessionId!: string | undefined;
    amountFrom!: number | undefined;
    amountTo!: number | undefined;
    externalTransactionId!: string | undefined;
    referenceId!: string | undefined;
    parentTransactionId!: string | undefined;
    isLiveMode!: boolean;
    referenceTypeId!: ReferenceTypeEnum | undefined;
    transactionTypeId!: TransactionTypeEnum | undefined;
    transactionStatusId!: TransactionStatusEnum | undefined;
    dateFrom!: Date | undefined;
    dateTo!: Date | undefined;

    constructor(data?: ITransactionSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.restaurantId = _data["restaurantId"];
            this.sessionId = _data["sessionId"];
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
            this.externalTransactionId = _data["externalTransactionId"];
            this.referenceId = _data["referenceId"];
            this.parentTransactionId = _data["parentTransactionId"];
            this.isLiveMode = _data["isLiveMode"];
            this.referenceTypeId = _data["referenceTypeId"];
            this.transactionTypeId = _data["transactionTypeId"];
            this.transactionStatusId = _data["transactionStatusId"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): TransactionSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TransactionSearchRequest>(data, _mappings, TransactionSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["restaurantId"] = this.restaurantId;
        data["sessionId"] = this.sessionId;
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        data["externalTransactionId"] = this.externalTransactionId;
        data["referenceId"] = this.referenceId;
        data["parentTransactionId"] = this.parentTransactionId;
        data["isLiveMode"] = this.isLiveMode;
        data["referenceTypeId"] = this.referenceTypeId;
        data["transactionTypeId"] = this.transactionTypeId;
        data["transactionStatusId"] = this.transactionStatusId;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ITransactionSearchRequest extends IBaseSearchRequest {
    id: string | undefined;
    restaurantId: string | undefined;
    sessionId: string | undefined;
    amountFrom: number | undefined;
    amountTo: number | undefined;
    externalTransactionId: string | undefined;
    referenceId: string | undefined;
    parentTransactionId: string | undefined;
    isLiveMode: boolean;
    referenceTypeId: ReferenceTypeEnum | undefined;
    transactionTypeId: TransactionTypeEnum | undefined;
    transactionStatusId: TransactionStatusEnum | undefined;
    dateFrom: Date | undefined;
    dateTo: Date | undefined;
}

export class BankInstrumentResponseModel implements IBankInstrumentResponseModel {
    account_number!: string;
    bank_code!: string;
    bban!: string;
    branch_code!: string;
    country!: string;
    currency!: string;
    iban!: string;
    id!: string;
    swift_bic!: string;
    type!: string;

    constructor(data?: IBankInstrumentResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.account_number = _data["account_number"];
            this.bank_code = _data["bank_code"];
            this.bban = _data["bban"];
            this.branch_code = _data["branch_code"];
            this.country = _data["country"];
            this.currency = _data["currency"];
            this.iban = _data["iban"];
            this.id = _data["id"];
            this.swift_bic = _data["swift_bic"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any, _mappings?: any): BankInstrumentResponseModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BankInstrumentResponseModel>(data, _mappings, BankInstrumentResponseModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account_number"] = this.account_number;
        data["bank_code"] = this.bank_code;
        data["bban"] = this.bban;
        data["branch_code"] = this.branch_code;
        data["country"] = this.country;
        data["currency"] = this.currency;
        data["iban"] = this.iban;
        data["id"] = this.id;
        data["swift_bic"] = this.swift_bic;
        data["type"] = this.type;
        return data;
    }
}

export interface IBankInstrumentResponseModel {
    account_number: string;
    bank_code: string;
    bban: string;
    branch_code: string;
    country: string;
    currency: string;
    iban: string;
    id: string;
    swift_bic: string;
    type: string;
}

export class BankInstrumentModel implements IBankInstrumentModel {
    accountNumber!: string;
    fullName!: string;
    address!: BaseAddress;
    phone!: Phone;
    bban!: string;
    iban!: string;
    swiftBic!: string;

    constructor(data?: IBankInstrumentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.accountNumber = _data["accountNumber"];
            this.fullName = _data["fullName"];
            this.address = _data["address"] ? BaseAddress.fromJS(_data["address"], _mappings) : <any>undefined;
            this.phone = _data["phone"] ? Phone.fromJS(_data["phone"], _mappings) : <any>undefined;
            this.bban = _data["bban"];
            this.iban = _data["iban"];
            this.swiftBic = _data["swiftBic"];
        }
    }

    static fromJS(data: any, _mappings?: any): BankInstrumentModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BankInstrumentModel>(data, _mappings, BankInstrumentModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountNumber"] = this.accountNumber;
        data["fullName"] = this.fullName;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["bban"] = this.bban;
        data["iban"] = this.iban;
        data["swiftBic"] = this.swiftBic;
        return data;
    }
}

export interface IBankInstrumentModel {
    accountNumber: string;
    fullName: string;
    address: BaseAddress;
    phone: Phone;
    bban: string;
    iban: string;
    swiftBic: string;
}

export class BaseAddress implements IBaseAddress {
    addressLine1!: string;
    addressLine2!: string;
    city!: string;
    state!: string;
    zip!: string;
    country!: string | undefined;

    constructor(data?: IBaseAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zip = _data["zip"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any, _mappings?: any): BaseAddress | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BaseAddress>(data, _mappings, BaseAddress);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        data["country"] = this.country;
        return data;
    }
}

export interface IBaseAddress {
    addressLine1: string;
    addressLine2: string;
    city: string;
    state: string;
    zip: string;
    country: string | undefined;
}

export class Phone implements IPhone {
    countryCode!: string;
    number!: string;

    constructor(data?: IPhone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any, _mappings?: any): Phone | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Phone>(data, _mappings, Phone);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode;
        data["number"] = this.number;
        return data;
    }
}

export interface IPhone {
    countryCode: string;
    number: string;
}

export class SupplierViewModel implements ISupplierViewModel {
    id!: string | undefined;
    restaurantId!: string | undefined;
    name!: string | undefined;
    notes!: string | undefined;
    labels!: string | undefined;
    supplierCategoryId!: SupplierCategoryTypeEnum;
    createdByPlatformUserId!: string | undefined;
    company!: CompanyViewModel | undefined;
    contacts!: PersonViewModel[] | undefined;

    constructor(data?: ISupplierViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.restaurantId = _data["restaurantId"];
            this.name = _data["name"];
            this.notes = _data["notes"];
            this.labels = _data["labels"];
            this.supplierCategoryId = _data["supplierCategoryId"];
            this.createdByPlatformUserId = _data["createdByPlatformUserId"];
            this.company = _data["company"] ? CompanyViewModel.fromJS(_data["company"], _mappings) : <any>undefined;
            if (Array.isArray(_data["contacts"])) {
                this.contacts = [] as any;
                for (let item of _data["contacts"])
                    this.contacts!.push(PersonViewModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): SupplierViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SupplierViewModel>(data, _mappings, SupplierViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["restaurantId"] = this.restaurantId;
        data["name"] = this.name;
        data["notes"] = this.notes;
        data["labels"] = this.labels;
        data["supplierCategoryId"] = this.supplierCategoryId;
        data["createdByPlatformUserId"] = this.createdByPlatformUserId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.contacts)) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISupplierViewModel {
    id: string | undefined;
    restaurantId: string | undefined;
    name: string | undefined;
    notes: string | undefined;
    labels: string | undefined;
    supplierCategoryId: SupplierCategoryTypeEnum;
    createdByPlatformUserId: string | undefined;
    company: CompanyViewModel | undefined;
    contacts: PersonViewModel[] | undefined;
}

export enum SupplierCategoryTypeEnum {
    RAW_MATERIALS = 1,
    DRINKS = 2,
    CLEANING = 3,
    CONSUMABLES = 4,
    SUPPLIES = 5,
    CONSULTANT = 6,
    TECHNOLOGY = 7,
    MARKETING = 8,
    RENT = 9,
    FURNITURE_AND_APPLIANCES = 10,
    FINANCE = 11,
    MAINTENANCE = 12,
    OTHER = 13,
    NOT_SET = -1,
}

export class PaginatedResultOfSupplierViewModel implements IPaginatedResultOfSupplierViewModel {
    items!: SupplierViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfSupplierViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SupplierViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfSupplierViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfSupplierViewModel>(data, _mappings, PaginatedResultOfSupplierViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfSupplierViewModel {
    items: SupplierViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class SupplierSearchRequest extends BaseSearchRequest implements ISupplierSearchRequest {
    supplierCategoryTypeId!: SupplierCategoryTypeEnum | undefined;

    constructor(data?: ISupplierSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.supplierCategoryTypeId = _data["supplierCategoryTypeId"];
        }
    }

    static fromJS(data: any, _mappings?: any): SupplierSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<SupplierSearchRequest>(data, _mappings, SupplierSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierCategoryTypeId"] = this.supplierCategoryTypeId;
        super.toJSON(data);
        return data;
    }
}

export interface ISupplierSearchRequest extends IBaseSearchRequest {
    supplierCategoryTypeId: SupplierCategoryTypeEnum | undefined;
}

export class CashTakingViewModel implements ICashTakingViewModel {
    id!: string | undefined;
    platformUserId!: string | undefined;
    restaurantCashboxId!: string | undefined;
    cashDrawerAmount!: number;
    cashAmount!: number;
    inAppAmount!: number;
    payoutsAmount!: number;
    hasNotesCount!: boolean;
    fiveCentsCount!: number | undefined;
    tenCentsCount!: number | undefined;
    twentyCentsCount!: number | undefined;
    fiftyCentsCount!: number | undefined;
    oneCount!: number | undefined;
    twoCount!: number | undefined;
    fiveCount!: number | undefined;
    tenCount!: number | undefined;
    twentyCount!: number | undefined;
    fiftyCount!: number | undefined;
    hundredCount!: number | undefined;
    twoHundredCount!: number | undefined;
    fiveHundredCount!: number | undefined;
    cardsAmount!: number;
    refundedAmount!: number;
    initialAmount!: number;
    createdAt!: Date;
    endDate!: Date | undefined;

    constructor(data?: ICashTakingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.platformUserId = _data["platformUserId"];
            this.restaurantCashboxId = _data["restaurantCashboxId"];
            this.cashDrawerAmount = _data["cashDrawerAmount"];
            this.cashAmount = _data["cashAmount"];
            this.inAppAmount = _data["inAppAmount"];
            this.payoutsAmount = _data["payoutsAmount"];
            this.hasNotesCount = _data["hasNotesCount"];
            this.fiveCentsCount = _data["fiveCentsCount"];
            this.tenCentsCount = _data["tenCentsCount"];
            this.twentyCentsCount = _data["twentyCentsCount"];
            this.fiftyCentsCount = _data["fiftyCentsCount"];
            this.oneCount = _data["oneCount"];
            this.twoCount = _data["twoCount"];
            this.fiveCount = _data["fiveCount"];
            this.tenCount = _data["tenCount"];
            this.twentyCount = _data["twentyCount"];
            this.fiftyCount = _data["fiftyCount"];
            this.hundredCount = _data["hundredCount"];
            this.twoHundredCount = _data["twoHundredCount"];
            this.fiveHundredCount = _data["fiveHundredCount"];
            this.cardsAmount = _data["cardsAmount"];
            this.refundedAmount = _data["refundedAmount"];
            this.initialAmount = _data["initialAmount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CashTakingViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CashTakingViewModel>(data, _mappings, CashTakingViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["platformUserId"] = this.platformUserId;
        data["restaurantCashboxId"] = this.restaurantCashboxId;
        data["cashDrawerAmount"] = this.cashDrawerAmount;
        data["cashAmount"] = this.cashAmount;
        data["inAppAmount"] = this.inAppAmount;
        data["payoutsAmount"] = this.payoutsAmount;
        data["hasNotesCount"] = this.hasNotesCount;
        data["fiveCentsCount"] = this.fiveCentsCount;
        data["tenCentsCount"] = this.tenCentsCount;
        data["twentyCentsCount"] = this.twentyCentsCount;
        data["fiftyCentsCount"] = this.fiftyCentsCount;
        data["oneCount"] = this.oneCount;
        data["twoCount"] = this.twoCount;
        data["fiveCount"] = this.fiveCount;
        data["tenCount"] = this.tenCount;
        data["twentyCount"] = this.twentyCount;
        data["fiftyCount"] = this.fiftyCount;
        data["hundredCount"] = this.hundredCount;
        data["twoHundredCount"] = this.twoHundredCount;
        data["fiveHundredCount"] = this.fiveHundredCount;
        data["cardsAmount"] = this.cardsAmount;
        data["refundedAmount"] = this.refundedAmount;
        data["initialAmount"] = this.initialAmount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICashTakingViewModel {
    id: string | undefined;
    platformUserId: string | undefined;
    restaurantCashboxId: string | undefined;
    cashDrawerAmount: number;
    cashAmount: number;
    inAppAmount: number;
    payoutsAmount: number;
    hasNotesCount: boolean;
    fiveCentsCount: number | undefined;
    tenCentsCount: number | undefined;
    twentyCentsCount: number | undefined;
    fiftyCentsCount: number | undefined;
    oneCount: number | undefined;
    twoCount: number | undefined;
    fiveCount: number | undefined;
    tenCount: number | undefined;
    twentyCount: number | undefined;
    fiftyCount: number | undefined;
    hundredCount: number | undefined;
    twoHundredCount: number | undefined;
    fiveHundredCount: number | undefined;
    cardsAmount: number;
    refundedAmount: number;
    initialAmount: number;
    createdAt: Date;
    endDate: Date | undefined;
}

export class PaginatedResultOfCashTakingViewModel implements IPaginatedResultOfCashTakingViewModel {
    items!: CashTakingViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfCashTakingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CashTakingViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfCashTakingViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfCashTakingViewModel>(data, _mappings, PaginatedResultOfCashTakingViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfCashTakingViewModel {
    items: CashTakingViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class CashTakingSearchRequest extends BaseSearchRequest implements ICashTakingSearchRequest {

    constructor(data?: ICashTakingSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
    }

    static fromJS(data: any, _mappings?: any): CashTakingSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CashTakingSearchRequest>(data, _mappings, CashTakingSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICashTakingSearchRequest extends IBaseSearchRequest {
}

export class PaginatedResultOfRestaurantTransactionViewModel implements IPaginatedResultOfRestaurantTransactionViewModel {
    items!: RestaurantTransactionViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfRestaurantTransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RestaurantTransactionViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfRestaurantTransactionViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfRestaurantTransactionViewModel>(data, _mappings, PaginatedResultOfRestaurantTransactionViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfRestaurantTransactionViewModel {
    items: RestaurantTransactionViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class RestaurantTransactionViewModel implements IRestaurantTransactionViewModel {
    id!: string | undefined;
    transactionStatusId!: TransactionStatusEnum;
    amount!: number;
    reference!: string | undefined;
    externalReferenceId!: string | undefined;
    paymentProviderId!: PaymentProviderEnum;
    supplierId!: string | undefined;
    notes!: string | undefined;
    createdByPlatformUserId!: string | undefined;
    includeFrom!: Date | undefined;
    includeTo!: Date | undefined;
    executed!: Date | undefined;
    transactionTypeId!: StoreTransactionTypeEnum;
    createdAt!: Date;

    constructor(data?: IRestaurantTransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.transactionStatusId = _data["transactionStatusId"];
            this.amount = _data["amount"];
            this.reference = _data["reference"];
            this.externalReferenceId = _data["externalReferenceId"];
            this.paymentProviderId = _data["paymentProviderId"];
            this.supplierId = _data["supplierId"];
            this.notes = _data["notes"];
            this.createdByPlatformUserId = _data["createdByPlatformUserId"];
            this.includeFrom = _data["includeFrom"] ? new Date(_data["includeFrom"].toString()) : <any>undefined;
            this.includeTo = _data["includeTo"] ? new Date(_data["includeTo"].toString()) : <any>undefined;
            this.executed = _data["executed"] ? new Date(_data["executed"].toString()) : <any>undefined;
            this.transactionTypeId = _data["transactionTypeId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): RestaurantTransactionViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RestaurantTransactionViewModel>(data, _mappings, RestaurantTransactionViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["transactionStatusId"] = this.transactionStatusId;
        data["amount"] = this.amount;
        data["reference"] = this.reference;
        data["externalReferenceId"] = this.externalReferenceId;
        data["paymentProviderId"] = this.paymentProviderId;
        data["supplierId"] = this.supplierId;
        data["notes"] = this.notes;
        data["createdByPlatformUserId"] = this.createdByPlatformUserId;
        data["includeFrom"] = this.includeFrom ? this.includeFrom.toISOString() : <any>undefined;
        data["includeTo"] = this.includeTo ? this.includeTo.toISOString() : <any>undefined;
        data["executed"] = this.executed ? this.executed.toISOString() : <any>undefined;
        data["transactionTypeId"] = this.transactionTypeId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRestaurantTransactionViewModel {
    id: string | undefined;
    transactionStatusId: TransactionStatusEnum;
    amount: number;
    reference: string | undefined;
    externalReferenceId: string | undefined;
    paymentProviderId: PaymentProviderEnum;
    supplierId: string | undefined;
    notes: string | undefined;
    createdByPlatformUserId: string | undefined;
    includeFrom: Date | undefined;
    includeTo: Date | undefined;
    executed: Date | undefined;
    transactionTypeId: StoreTransactionTypeEnum;
    createdAt: Date;
}

export enum StoreTransactionTypeEnum {
    PLATFORM_PAYIN = 1,
    PLATFORM_PAYOUT = 2,
    SUPPLIER_PAYOUT = 3,
    SUPPLIER_REFUND = 4,
    INVOICE_PAYOUT = 5,
    EMPLOYEE_PAYOUT = 6,
    TAX_PAYOUT = 7,
    PAYMENT_METHOD_VERIFICATION = 8,
}

export class RestaurantTransactionSearchRequest extends BaseSearchRequest implements IRestaurantTransactionSearchRequest {
    transactionTypeId!: StoreTransactionTypeEnum | undefined;
    manualOnly!: boolean | undefined;

    constructor(data?: IRestaurantTransactionSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.transactionTypeId = _data["transactionTypeId"];
            this.manualOnly = _data["manualOnly"];
        }
    }

    static fromJS(data: any, _mappings?: any): RestaurantTransactionSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RestaurantTransactionSearchRequest>(data, _mappings, RestaurantTransactionSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionTypeId"] = this.transactionTypeId;
        data["manualOnly"] = this.manualOnly;
        super.toJSON(data);
        return data;
    }
}

export interface IRestaurantTransactionSearchRequest extends IBaseSearchRequest {
    transactionTypeId: StoreTransactionTypeEnum | undefined;
    manualOnly: boolean | undefined;
}

export class DeviceLoginResponse implements IDeviceLoginResponse {
    restaurantId!: string | undefined;
    users!: PlatformUserViewModel[] | undefined;
    device!: DeviceViewModel | undefined;
    deviceConnectionToken!: string | undefined;

    constructor(data?: IDeviceLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.restaurantId = _data["restaurantId"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(PlatformUserViewModel.fromJS(item, _mappings));
            }
            this.device = _data["device"] ? DeviceViewModel.fromJS(_data["device"], _mappings) : <any>undefined;
            this.deviceConnectionToken = _data["deviceConnectionToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): DeviceLoginResponse | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeviceLoginResponse>(data, _mappings, DeviceLoginResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["restaurantId"] = this.restaurantId;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["deviceConnectionToken"] = this.deviceConnectionToken;
        return data;
    }
}

export interface IDeviceLoginResponse {
    restaurantId: string | undefined;
    users: PlatformUserViewModel[] | undefined;
    device: DeviceViewModel | undefined;
    deviceConnectionToken: string | undefined;
}

export class PlatformUserViewModel implements IPlatformUserViewModel {
    id!: string;
    username!: string;
    token!: string | undefined;
    langCode!: string | undefined;
    suppliers!: SupplierViewModel[];
    restaurants!: StoreViewModel[];
    mappedRestaurants!: { [key: string]: string; };
    supplierIds!: string[] | undefined;
    restaurantIds!: string[] | undefined;
    isActive!: boolean;
    parentName!: string | undefined;
    password!: string | undefined;
    email!: string | undefined;
    role!: RoleViewModel;
    parentId!: string | undefined;
    timeZoneId!: string | undefined;
    pin!: string | undefined;
    hasAuthenticatorEnabled!: boolean;

    constructor(data?: IPlatformUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.suppliers = [];
            this.restaurants = [];
            this.mappedRestaurants = {};
            this.role = new RoleViewModel();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.token = _data["token"];
            this.langCode = _data["langCode"];
            if (Array.isArray(_data["suppliers"])) {
                this.suppliers = [] as any;
                for (let item of _data["suppliers"])
                    this.suppliers!.push(SupplierViewModel.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["restaurants"])) {
                this.restaurants = [] as any;
                for (let item of _data["restaurants"])
                    this.restaurants!.push(StoreViewModel.fromJS(item, _mappings));
            }
            if (_data["mappedRestaurants"]) {
                this.mappedRestaurants = {} as any;
                for (let key in _data["mappedRestaurants"]) {
                    if (_data["mappedRestaurants"].hasOwnProperty(key))
                        (<any>this.mappedRestaurants)![key] = _data["mappedRestaurants"][key];
                }
            }
            if (Array.isArray(_data["supplierIds"])) {
                this.supplierIds = [] as any;
                for (let item of _data["supplierIds"])
                    this.supplierIds!.push(item);
            }
            if (Array.isArray(_data["restaurantIds"])) {
                this.restaurantIds = [] as any;
                for (let item of _data["restaurantIds"])
                    this.restaurantIds!.push(item);
            }
            this.isActive = _data["isActive"];
            this.parentName = _data["parentName"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.role = _data["role"] ? RoleViewModel.fromJS(_data["role"], _mappings) : new RoleViewModel();
            this.parentId = _data["parentId"];
            this.timeZoneId = _data["timeZoneId"];
            this.pin = _data["pin"];
            this.hasAuthenticatorEnabled = _data["hasAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any, _mappings?: any): PlatformUserViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PlatformUserViewModel>(data, _mappings, PlatformUserViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["token"] = this.token;
        data["langCode"] = this.langCode;
        if (Array.isArray(this.suppliers)) {
            data["suppliers"] = [];
            for (let item of this.suppliers)
                data["suppliers"].push(item.toJSON());
        }
        if (Array.isArray(this.restaurants)) {
            data["restaurants"] = [];
            for (let item of this.restaurants)
                data["restaurants"].push(item.toJSON());
        }
        if (this.mappedRestaurants) {
            data["mappedRestaurants"] = {};
            for (let key in this.mappedRestaurants) {
                if (this.mappedRestaurants.hasOwnProperty(key))
                    (<any>data["mappedRestaurants"])[key] = (<any>this.mappedRestaurants)[key];
            }
        }
        if (Array.isArray(this.supplierIds)) {
            data["supplierIds"] = [];
            for (let item of this.supplierIds)
                data["supplierIds"].push(item);
        }
        if (Array.isArray(this.restaurantIds)) {
            data["restaurantIds"] = [];
            for (let item of this.restaurantIds)
                data["restaurantIds"].push(item);
        }
        data["isActive"] = this.isActive;
        data["parentName"] = this.parentName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["parentId"] = this.parentId;
        data["timeZoneId"] = this.timeZoneId;
        data["pin"] = this.pin;
        data["hasAuthenticatorEnabled"] = this.hasAuthenticatorEnabled;
        return data;
    }
}

export interface IPlatformUserViewModel {
    id: string;
    username: string;
    token: string | undefined;
    langCode: string | undefined;
    suppliers: SupplierViewModel[];
    restaurants: StoreViewModel[];
    mappedRestaurants: { [key: string]: string; };
    supplierIds: string[] | undefined;
    restaurantIds: string[] | undefined;
    isActive: boolean;
    parentName: string | undefined;
    password: string | undefined;
    email: string | undefined;
    role: RoleViewModel;
    parentId: string | undefined;
    timeZoneId: string | undefined;
    pin: string | undefined;
    hasAuthenticatorEnabled: boolean;
}

export class LoginRequest implements ILoginRequest {
    username!: string;
    password!: string;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any, _mappings?: any): LoginRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginRequest>(data, _mappings, LoginRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    username: string;
    password: string;
}

export class LoginAuthenticatorRequest implements ILoginAuthenticatorRequest {
    authenticatorCode!: string | undefined;
    key!: string | undefined;

    constructor(data?: ILoginAuthenticatorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.authenticatorCode = _data["authenticatorCode"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any, _mappings?: any): LoginAuthenticatorRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginAuthenticatorRequest>(data, _mappings, LoginAuthenticatorRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticatorCode"] = this.authenticatorCode;
        data["key"] = this.key;
        return data;
    }
}

export interface ILoginAuthenticatorRequest {
    authenticatorCode: string | undefined;
    key: string | undefined;
}

export class ValueTupleOfStringAndString implements IValueTupleOfStringAndString {
    item1!: string;
    item2!: string;

    constructor(data?: IValueTupleOfStringAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any, _mappings?: any): ValueTupleOfStringAndString | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ValueTupleOfStringAndString>(data, _mappings, ValueTupleOfStringAndString);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data;
    }
}

export interface IValueTupleOfStringAndString {
    item1: string;
    item2: string;
}

export class ChangeSettingsRequest implements IChangeSettingsRequest {
    langCode!: string | undefined;
    showTour!: boolean;
    email!: string | undefined;
    timeZoneId!: string | undefined;

    constructor(data?: IChangeSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.langCode = _data["langCode"];
            this.showTour = _data["showTour"];
            this.email = _data["email"];
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChangeSettingsRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangeSettingsRequest>(data, _mappings, ChangeSettingsRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["langCode"] = this.langCode;
        data["showTour"] = this.showTour;
        data["email"] = this.email;
        data["timeZoneId"] = this.timeZoneId;
        return data;
    }
}

export interface IChangeSettingsRequest {
    langCode: string | undefined;
    showTour: boolean;
    email: string | undefined;
    timeZoneId: string | undefined;
}

export class ChangePinRequest implements IChangePinRequest {
    currentPin!: string | undefined;
    newPin!: string | undefined;

    constructor(data?: IChangePinRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.currentPin = _data["currentPin"];
            this.newPin = _data["newPin"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChangePinRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangePinRequest>(data, _mappings, ChangePinRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPin"] = this.currentPin;
        data["newPin"] = this.newPin;
        return data;
    }
}

export interface IChangePinRequest {
    currentPin: string | undefined;
    newPin: string | undefined;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    currentPassword!: string | undefined;
    newPassword!: string | undefined;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChangePasswordRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangePasswordRequest>(data, _mappings, ChangePasswordRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordRequest {
    currentPassword: string | undefined;
    newPassword: string | undefined;
}

export class PaginatedResultOfPlatformUserViewModel implements IPaginatedResultOfPlatformUserViewModel {
    items!: PlatformUserViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfPlatformUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PlatformUserViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfPlatformUserViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfPlatformUserViewModel>(data, _mappings, PaginatedResultOfPlatformUserViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfPlatformUserViewModel {
    items: PlatformUserViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class PlatformUserSearchRequest extends BaseSearchRequest implements IPlatformUserSearchRequest {
    id!: string | undefined;
    username!: string | undefined;
    isActive!: boolean | undefined;
    parentUsername!: string | undefined;
    roleId!: string | undefined;
    restaurantId!: string | undefined;

    constructor(data?: IPlatformUserSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.isActive = _data["isActive"];
            this.parentUsername = _data["parentUsername"];
            this.roleId = _data["roleId"];
            this.restaurantId = _data["restaurantId"];
        }
    }

    static fromJS(data: any, _mappings?: any): PlatformUserSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PlatformUserSearchRequest>(data, _mappings, PlatformUserSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["isActive"] = this.isActive;
        data["parentUsername"] = this.parentUsername;
        data["roleId"] = this.roleId;
        data["restaurantId"] = this.restaurantId;
        super.toJSON(data);
        return data;
    }
}

export interface IPlatformUserSearchRequest extends IBaseSearchRequest {
    id: string | undefined;
    username: string | undefined;
    isActive: boolean | undefined;
    parentUsername: string | undefined;
    roleId: string | undefined;
    restaurantId: string | undefined;
}

export class PaginatedResultOfVoucherViewModel implements IPaginatedResultOfVoucherViewModel {
    items!: VoucherViewModel[];
    totalRecords!: number;
    pageSize!: number;
    currentPageIdx!: number;
    totalPages!: number;

    constructor(data?: IPaginatedResultOfVoucherViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VoucherViewModel.fromJS(item, _mappings));
            }
            this.totalRecords = _data["totalRecords"];
            this.pageSize = _data["pageSize"];
            this.currentPageIdx = _data["currentPageIdx"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any, _mappings?: any): PaginatedResultOfVoucherViewModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PaginatedResultOfVoucherViewModel>(data, _mappings, PaginatedResultOfVoucherViewModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalRecords"] = this.totalRecords;
        data["pageSize"] = this.pageSize;
        data["currentPageIdx"] = this.currentPageIdx;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedResultOfVoucherViewModel {
    items: VoucherViewModel[];
    totalRecords: number;
    pageSize: number;
    currentPageIdx: number;
    totalPages: number;
}

export class VoucherSearchRequest extends BaseSearchRequest implements IVoucherSearchRequest {

    constructor(data?: IVoucherSearchRequest) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
    }

    static fromJS(data: any, _mappings?: any): VoucherSearchRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<VoucherSearchRequest>(data, _mappings, VoucherSearchRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IVoucherSearchRequest extends IBaseSearchRequest {
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}